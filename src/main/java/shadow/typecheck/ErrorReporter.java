package shadow.typecheck;

import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.Logger;

import shadow.Main;
import shadow.parser.javacc.Node;
import shadow.typecheck.TypeCheckException.Error;
import shadow.typecheck.type.ArrayType;
import shadow.typecheck.type.ModifiedType;
import shadow.typecheck.type.SequenceType;
import shadow.typecheck.type.Type;

public class ErrorReporter {
	protected final ArrayList<TypeCheckException> errorList = new ArrayList<TypeCheckException>();
	protected final ArrayList<TypeCheckException> warningList = new ArrayList<TypeCheckException>();	
	
	private final Logger LOGGER;
	
	public ErrorReporter(Logger logger) {
		LOGGER = logger;
	}	
	
	public void clearErrors() {
		errorList.clear();
		warningList.clear();
	}
	
	public List<TypeCheckException> getErrorList() {
		return errorList;
	}
	
	public List<TypeCheckException> getWarningList() {
		return warningList;
	}
	
	/**
	 * Adds a temporary list of errors associated with a particular 
	 * node to the main list of errors.
	 * @param node				node related to errors
	 * @param errors			list of errors
	 */	
	public final void addErrors(Node node, List<TypeCheckException> errors ) {		
		if( errors != null )
			for( TypeCheckException error : errors )
				addError( node, error.getError(), error.getMessage() );
	}
	
	/**
	 * Adds an error associated with a node to the main list of errors.
	 * @param node				node related to error	
	 * @param error				kind of error
	 * @param message			message explaining error
	 * @param errorTypes		types associated with error
	 */
	public void addError(Node node, Error error, String message, Type... errorTypes) {
		if( containsUnknown(errorTypes) )
			return; // Don't add error if it has an unknown type in it.
		
		if( node != null ) 
			errorList.add(new TypeCheckException(error, message, node.getFile(), node.getLineStart(),
					node.getLineEnd(), node.getColumnStart(), node.getColumnEnd() ));	
	}
	

	
	/**
	 * Adds a warning associated with a node to the main list of warnings.
	 * @param node				node related to warning	
	 * @param warning			kind of warning
	 * @param message			message explaining warning
	 */
	public void addWarning(Node node, Error warning, String message) {
		if( Main.getJob().treatWarningsAsErrors() )
			addError(node, warning, message);
		else if( node != null )
			warningList.add(new TypeCheckException(warning, message, node.getFile(), node.getLineStart(),
					node.getLineEnd(), node.getColumnStart(), node.getColumnEnd() ));	
	}
	
	/**
	 * Prints the list of errors to the appropriate logger.
	 */
	public final void printErrors() {
		for(TypeCheckException exception : errorList)
			LOGGER.error(exception.getMessage());
	}
	
	/**
	 * Prints the list of warnings to the appropriate logger.
	 */
	public final void printWarnings() {
		for(TypeCheckException exception : warningList)
			LOGGER.warn(exception.getMessage());
	}
	
	
	/**
	 * Checks to see if the array contains an unknown type. 
	 * @param types	array of types to be checked
	 * @return 		if the array contains <code>Type.UNKNOWN</code>
	 * @see			Type.UNKNOWN
	 */
	protected static boolean containsUnknown( Type[] types ) {
		for( Type type : types )
			if( containsUnknown(type) )
				return true;
		
		return false;
	}
	
	/**
	 * Checks to see if the type is unknown or contains an unknown type.
	 * Unknown types are generated by the type-checker to avoid 
	 * null pointer exceptions, but errors involving unknown types are
	 * suppressed to avoid a cascade of errors from the same source.
	 * @param type	type to be checked
	 * @return 		if the type contains <code>Type.UNKNOWN</code>
	 * @see			Type.UNKNOWN
	 */
	private static boolean containsUnknown( Type type ) {
		if( type == null )
			return false;
		if( type == Type.UNKNOWN )
			return true;
		if( type instanceof SequenceType ) {
			SequenceType sequenceType = (SequenceType) type;
			for(ModifiedType modifiedType : sequenceType)
				if( containsUnknown( modifiedType.getType() ) )
					return true;
		}
		else if( type instanceof ArrayType )
			return containsUnknown( ((ArrayType)type).getBaseType() );
		
		return false;
	}
	
	/**
	 * Adds an error to the given error list, unless that error refers to 
	 * unknown types. Unknown type errors are usually symptoms of other errors
	 * (like undeclared variables), and are thus unnecessary to report.
	 * @param errors		list of errors
	 * @param type			kind of error
	 * @param reason		message explaining error
	 * @param errorTypes	types of errors involved, used for suppressing redundant errors
	 */
	public static void addError( List<TypeCheckException> errors, Error type,
			String reason, Type... errorTypes ) {
		// Don't add an error if it has an Unknown Type in it.
		if( containsUnknown( errorTypes ) )
			return; 		
		if( errors != null )
			errors.add( new TypeCheckException( type, reason ) );		
	}

	public void addAll(ErrorReporter other)
	{
		errorList.addAll(other.errorList);
		warningList.addAll(other.warningList);
	}	
	
	public void removeRedundantErrors()
	{		
		removeRedundantErrors(errorList);
		removeRedundantErrors(warningList);		
	}	
	
	private static void removeRedundantErrors(List<TypeCheckException> list)
	{
		for( int i = 0; i < list.size();  ) {
			boolean redundant = false;
			TypeCheckException item = list.get(i);
			for( int j = 0; j < list.size() && !redundant; ++j ) {
				TypeCheckException other = list.get(j);
				if( i != j && item.getError() == other.getError() && item.isInside(other) )
					redundant = true;
			}
			
			if( redundant )
				list.remove(i);
			else
				++i;
		}
	}

}
