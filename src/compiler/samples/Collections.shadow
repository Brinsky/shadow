class Collections
{
	public static map<T, U is Collection, V>( U<T> collection, (T)=>(V) transform ) => (U<V>)
	{
		V[] array = new V[collection.getSize()];
		
		int i = 0;		
		foreach( T value in collection )
		{
			array[i] = transform( value );
			i += 1;			
		}
		
		return new U<V>( array );
	}
	
	public static reduce<T>( Collection<T> collection, (U,T)=>(U) combine, U initial ) => (U)
	{
		U total = initial;		
				
		foreach( T value in collection )
		{
			total = combine(total, value);			
		}
		
		return total;
	}
	
	public static transform<T>( AuditableCollection<T> collection, (T)=>(T) transform  )
	{
		Auditor<T> auditor = collection.getAuditor();
		
		while( auditor.isValid() )
		{
			auditor.setValue( transform( auditor.getValue() ) );
			auditor = auditor.getNext();	
		}
	}
	
	public static sort<T is Comparable<T>, U is MutableCollection<T>>, ( U collection ) => ()
	{
		sort<T, U>( collection, T.compare );
	}
	
	public static sort<T, U is MutableCollection<T>>( U collection, (T,T)=>(int) compare ) => ()
	{
		if( U is Sortable )
		{
			Sortable<T> sortable = cast<Sortable<T>>( collection );
			sortable.sort( compare );
		}
		else //maybe add more optimizations later?  Test empirically?
		{
			T[] array = collection.toArray();
			array.sort( compare );
			collection.clear();
			collection.addAll( array ); 					
		}	 	
	}

	/**
		Sort array of Comparable types	
	*/
	public static sort<T is Comparable<T> >( T[] array ) => ()
	{
		sort( array, T.compare );
	}
	
	
	/**
		Sort array with comparator function	
	*/
	public static sort<T>( T[] array, (T,T)=>(int) compare ) => ()
	{
		quicksort( array, 0, array.length - 1, compare );
	}
	
	
	/**
		Private recursive quicksort used for sorting arrays	
	*/	
	
	private static quicksort<T>( T[] array, int left, int right, (T,T)=>(int) compare )
	{
		if( right > left )
		{
			// pick middle value as pivot value, avoids worst case for sorted lists
			// perhaps median of 3 eventually?
			int pivot = partition( array, left, right, (left + right) / 2, compare );
			quicksort( array, left, pivot - 1, compare );
			quicksort( array, pivot + 1, right, compare );		
		}	
	}
	
	/**
		Private partition helper method for quicksort	
	*/
	
	private static partition<T>( T[] array, int left, int right, int pivot, (T,T)=>(int) compare )
	{			
			T pivotValue = array[pivot];	//save pivot
			array[pivot] = array[right];	//put rightmost where pivot was
			
			// move smaller values to the left
			for( int i = left; i < right; i += 1 )
			{
				if( compare( array[i], pivotValue ) < 0 )
				{
					T temp = array[i];
					array[i] = array[left];
					array[left] = temp;
					left += 1;				
				}			
			}
						
			array[right] = array[left];		//make space for pivot
			array[left] = pivotValue;		//put pivot in proper location
			return left;					//return pivot location
	}	
}