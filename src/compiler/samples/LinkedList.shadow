class LinkedList<T> implements List<T>
{
	private class Node<T> extends BidirectionalAuditor<T>
	{
	 	T value = null;
		Node<T> next = null;
		Node<T> previous = null;
		
		public create( T value, Node<T> next, Node<T> previous )
		{
			this.value = value;
			this.next = next;
			this.previous = previous;		
		}
		
		public immutable getValue() => (T)
		{
			return value;
		}
		
		public immutable getNext() => (Node<T>)
		{
			return next;
		}
		
		public immutable isValid() => (boolean)
		{
			return (this != tail && this != head);
		} 
		
		public immutable getPrevious() => (Node<T>)
		{
			return previous;
		}
		
		public setValue(T value) => ()
		{
			this.value = value;			
		}
		
		public setNext(Node<T> next) => ()
		{
			this.next = next;			
		}
		
		public setPrevious(Node<T> previous) => ()
		{
			this.previous = previous;			
		}
			
	}

	int size = 0;
	//dummy head and tail
	Node<T> head = new Node<T>( null, null, null );
	Node<T> tail = new Node<T>( null, null, null );

	public create()
	{
		head.setNext( tail );
		tail.setPrevious( head );
	}
	
	public create( Collection<S is T> collection )
	{
		addAll( collection );
	}
	
	//add to end
	public add(T value) => ()
	{
		Node<T> previous = tail.getPrevious();
		Node<T> next = tail;
		Node<T> node = new Node<T>( value, next, previous() );
		previous.setNext( node );
		next.setPrevious( node );
		size += 1;
	}
	
	public getIterator() => (Node<T>)
	{
		return head.getNext();
	}
	
	public getAuditor() => (Node<T>)
	{
		return head.getNext();
	}	
	
	private getNode( int index ) => ( Node<T> ) throws List.IndexOutOfBoundsError
	{
		if( index >= size || index < 0 )
			throw List.IndexOutOfBoundsError;	
	
		if( index < size - 1 - index ) //start from front
		{			
			Node<T> current = head.getNext();
			for( int i = 0; i < index; i += 1 )
				current = current.getNext();
			return current;			
		}
		else							//start from back
		{
			Node<T> current = tail.getPrevious();
			for( int i = size - 1; i > index; i -= 1 )
				current = current.getPrevious();
			return current;
		}
	} 
	
	public immutable get(int index) => (T) throws List.IndexOutOfBoundsError
	{
		return getNode( index ).getValue();
	}
	
	public set(int index, T value ) => () throws List.IndexOutOfBoundsError
	{
		getNode( index ).setValue( value );
	}
	
	
	public addAll( Collection<S is T> collection ) => ()
	{
		foreach( S value in collection )
			add( value );
	}
	
	private remove( Node<T> node ) => ( Node<T> )
	{
		Node<T> next = node.getNext();
		Node<T> previous = temp.getPrevious();
		previous.setNext( next );
		next.setPrevious( previous );			
		node.setNext( null );
		node.setPrevious( null );
		delete node;
		size--;
		return next;		
	}
	 
	public clear() => ()
	{
		Node<T> current = head.getNext();
		while( size > 0 )
			current = remove( current );	
	}		
	
	//remove the first occurrence of value
	public remove( T value ) => ()
	{
		Node<T> current = head.getNext();
		while( current != tail && !current.getValue().equals( value ) ) 
			current = current.getNext();
			
		if( current != tail )		
			remove( current );
	}
	

	public removeAll( (T)=>(boolean) condition ) => ()
	{
		Node<T> current = head.getNext();
		while( current != tail )
		{
			if( condition( current.getValue() )
				current = remove( current );
			else
				current = current.getNext();
		} 
	}	
	
	public contains( T value ) => (boolean)
	{
		Node<T> current = head.getNext();
		while( current != tail )
		{		
			if( current.getValue().equals( value ) )
				return true;
			else
				current = current.getNext();
		}
				
		return false;	
	}
	
	public containsAll( Collection<S is T> collection ) => (boolean)
	{
		foreach(S value in collection )
			if( !contains( value ) )
				return false;
				
		return true;
	}
	
	public isEmpty() => (boolean)
	{
		return size == 0;
	}
	
	public immutable getSize() => (int)
	{
		return size;
	}
	
	public immutable toArray() => (T[])
	{
		T[] array = new T[size];
		Node<T> current = head.getNext();
		for( int i = 0; i < size; i += 1 )		
		{
			array[i] = current.getValue();
			current = current.getNext();
		}
		
		return array;			
	}
}