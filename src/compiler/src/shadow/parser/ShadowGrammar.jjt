/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.5";
}
PARSER_BEGIN(ShadowParser)
package shadow.parser.javacc;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.*;

public class ShadowParser {

    private boolean debug = true;
    
	public static void main(String args[]) throws ParseException {
		try {
//            String fileName = "tests/full_input_test.shadow";
//            String fileName = "tests/class_test.shadow";
            String fileName = "tests/expressions.shadow";
            FileInputStream fis = new FileInputStream(fileName);
	    	ShadowParser parser = new ShadowParser(fis);
	
			System.out.println("Reading file: " + fileName);

			SimpleNode n = parser.TranslationUnit();

			n.dump("");
			System.out.println("GOOD PARSE");
			
		} catch (ParseException e) {
			System.out.println("BAD PARSE");
			System.out.println(e.getMessage());
		} catch (Error e) {
			System.out.println("Oops.");
			System.out.println(e.getMessage());
		} catch(FileNotFoundException e) {
			System.out.println(e.getMessage());
		}
	}

    public void debugPrint(String str) {
        if(debug)
            System.out.println(str + ": " + token);
    }
}
PARSER_END(ShadowParser)

SKIP : {
		" "
	|	"\r"
	|	"\t"
	|	"\n"
	|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {	// literals
	   < INTEGER_LITERAL: <DECIMAL_LITERAL> | <HEX_LITERAL> >
	|  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
	|  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
	|  < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])+ >
	|  < CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
	|  < STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

/**
 * Key words below
 */
TOKEN : { 	// primative types
		< BOOL: "bool" >
	|	< BYTE: "byte" >
	|	< UBYTE: "ubyte" >				
	|	< SHORT: "short" > 
	|	< USHORT: "ushort" > 
	|	< INT: "int"> 
	|	< UINT: "uint"> 
	|	< LONG: "long"> 
	|	< ULONG: "ulong"> 
	|	< FLOAT: "float" >
	|	< CODE: "code" >
	|	< VOID: "void" >
}

TOKEN : {	// control flow keywords				
		<IF: "if"> 
	|	<ELSE: "else"> 
	|	<FOR: "for"> 
	|	<FOREACH: "foreach"> 
	|	<WHILE: "while"> 
	|	<DO: "do">
	|	<CONTINUE: "continue">
	|	<BREAK: "break"> 
	|	<SWITCH: "switch"> 
	|	<CASE: "case"> 
	|	<DFLT: "default"> 
	|	<RETURN: "return"> 
}

TOKEN : {	// data types
		< CLASS: "class" >
	|	< TUPLE: "tuple" >
	|	< INTERFACE: "interface" >
	|	< ERROR: "error" >
	|	< EXCEPTION: "exception" >
}

TOKEN : {	// inheritance
		< EXTENDS: "extends" >
	|	< IMPLEMENTS: "implements" >
}

TOKEN: {	// exceptions
		< THROW: "throw" >
	|	< THROWS: "throws" >
	|	< RETHROW: "rethrow" >
	|	< TRY: "try" >
	|	< CATCH: "catch" >
}

TOKEN : {    < THIS: "this" >
  |	< SUPER: "super" >
}

TOKEN : {	// memory management
		< NEW: "new" >
	|	< DELETE: "delete" >
//	|	< DELETEFROM: "delete from" >
}

TOKEN : {	// visibility
		< PUBLIC: "public" >
	|	< PROTECTED: "protected" >
	|	< PRIVATE: "private" >
}

TOKEN : {   // misc
        < CAST: "cast" >
}
	 
/**
 * These are our identifiers. They must be below everything else
 */
TOKEN : {	// identifiers
		<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* > { System.out.println("IDENTIFIER"); }
	|	<#LETTER: ["A"-"Z","_","a"-"z"]>
	|	<#DIGIT: ["0"-"9"]>
}

void Literal() : { debugPrint("LITERAL"); }
{
		< INTEGER_LITERAL >
	|	< FLOATING_POINT_LITERAL >
	|	< CHARACTER_LITERAL > { debugPrint("CHARACTER LITERAL"); }
	|	< STRING_LITERAL >
}

void BuiltInType() : { } {
		< BOOL >
	|	< BYTE >
	|	< UBYTE >				
	|	< SHORT > 
	|	< USHORT > 
	|	< INT > 
	|	< UINT > 
	|	< LONG > 
	|	< ULONG > 
	|	< FLOAT >
	|	< CODE >
}

void TypeId() : { }
{
    // we'll need to add something to check for types we know about later
    BuiltInType()
}

void Dims() : { }
{
    "[]" [ Dims() ]
}

/**
 * Expression tree
 */
void ExpressionStatement() : { debugPrint("EXPRESSION STATEMENT"); }
{
    [ Expression() ] ";"
}

void Expression() : { debugPrint("EXPRESSION"); }
{
    AssignmentExpression() //( "," AssignmentExpression() )*
}

void AssignmentExpression() : { debugPrint("ASSIGNMENT EXPRESSION"); }
{
//    LOOKAHEAD(3) ConditionalExpression() | Assignment()
    Assignment()
}

void Assignment() : { debugPrint("ASSIGNMENT"); }
{
//      ( LeftHandSide() AssignmentOperator() )+ ConditionalExpression()
      LeftHandSide() AssignmentOperator() ConditionalExpression()
}

void LeftHandSide() : { debugPrint("LEFT HAND SIDE"); }
{
//    < IDENTIFIER > [ "[" ConditionalExpression() "]" ] ( "." DataMemberArrayAccess() )*
    DataMemberArrayAccess() ( "." DataMemberArrayAccess() )*
}

void AssignmentOperator() : { debugPrint("ASSIGNMENT OPERATOR"); }
{
    ( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" | "#=" )
    
}

void ConditionalExpression() : { debugPrint("CONDITIONAL EXPRESSION"); }
{
    LogicalORExpression() [ "?" ConditionalExpression() ":" ConditionalExpression() ]
}

void LogicalORExpression() : {}
{
    LogicalANDExpression() [ "||" LogicalORExpression() ]
}

void LogicalANDExpression() : {}
{
    InclusiveORExpression() [ "&&" LogicalANDExpression() ]
}

void InclusiveORExpression() : {}
{
    ExclusiveORExpression() [ "|" InclusiveORExpression() ]
}

void ExclusiveORExpression() : {}
{
    ANDExpression() [ "^" ExclusiveORExpression() ]
}

void ANDExpression() : {}
{
    EqualityExpression() [ "&" ANDExpression() ]
}

void EqualityExpression() : {}
{
    RelationalExpression() [ ( "==" | "!=" ) EqualityExpression() ]
}

void RelationalExpression() : {}
{
    ShiftExpression() [ ( "<" | ">" | "<=" | ">=" ) RelationalExpression() ]
}

void ShiftExpression() : {}
{
	// we could add <<< and >>> which would be rotate 
    AdditiveExpression() [ ( "<<" | ">>" ) ShiftExpression() ]
}

void AdditiveExpression() : {}
{
    MultiplicativeExpression() [ ( "+" | "-" ) AdditiveExpression() ]
}

void MultiplicativeExpression() : {}
{
    UnaryExpression() [ ( "*" | "/" | "%" ) MultiplicativeExpression() ]
}

void UnaryExpression() : { debugPrint("UNARY EXPRESSION"); }
{
    "+" UnaryExpression() | "-" UnaryExpression() | UnaryNotPlusMinusExpression()
}

void UnaryNotPlusMinusExpression() : { debugPrint("UNARY NOT +- EXPRESSION"); }
{
    PrimaryExpression() | "!" UnaryExpression() | "~" UnaryExpression() | CastExpression()
}

void CastExpression() : { debugPrint("CAST EXPRESSION"); }
{
    < CAST > "<" TypeId() [ Dims() ] ">" "(" UnaryExpression() ")" 
}

/*
void PostfixExpression() : { debugPrint("POSTFIX EXPRESSION"); }
{
    LOOKAHEAD(PrimaryExpression()) PrimaryExpression() | <IDENTIFIER>
}
*/

void PrimaryExpression() : { debugPrint("PRIMARY EXPRESSION"); }
{
    LOOKAHEAD(3) ArrayCreationExpression() | PrimaryNoNewArrayExpression()
}

void PrimaryNoNewArrayExpression() : { debugPrint("PRIMARY NO NEW ARRAY"); }
{
      Literal() { debugPrint("PRIMARY -> LITERAL"); }
    | < THIS >
    | "(" ConditionalExpression() ")" { debugPrint("PRIMARY -> EXPRESSION"); }    | < NEW > TypeId() ( "(" [ ArgumentList() ] ")" | "[" ConditionalExpression() "]" [ Dims() ] ) 
    | ( DataMemberAccessList() )+ { debugPrint("PRIMARY -> DATA MEMBER ACCESS LIST"); }
}

void ArrayCreationExpression() : { debugPrint("ARRAY CREATION"); }
{
    < NEW > TypeId() "[" ConditionalExpression() "]" [ Dims() ]
}

void DataMemberArrayAccess() : { debugPrint("DATA MEMBER ARRAY ACCESS"); }
{
    < IDENTIFIER > { debugPrint("\tIDENTIFIER"); } [ "[" ConditionalExpression() "]" ]
}

void MethodInvocation() : { debugPrint("METHOD INVOCATION"); }
{
    < IDENTIFIER > [ "(" [ ArgumentList() ] ")" ]
}

void DataMemberAccessList() : { debugPrint("DATA MEMBER ACCESS LIST"); }
{
    LOOKAHEAD(2) DataMemberArrayAccess() | MethodInvocation()  ( "." ( LOOKAHEAD(2) DataMemberArrayAccess() | MethodInvocation() ) )*
}

void ArgumentList() : {}
{
    ConditionalExpression() ( "," ConditionalExpression() )*
}

/**
 * High-level object definitions
 */
void Visibility() : { }
{
		< PUBLIC >
	|	< PROTECTED >
	|	< PRIVATE >
}

void ExpressionList() : { debugPrint("EXPRESSION LIST"); }
{
    ( LOOKAHEAD(3) Expression() | ConditionalExpression() ) ( "," ( LOOKAHEAD(3) Expression() | ConditionalExpression() ) )* 
}

void VariableDeclaration() : { debugPrint("VAR DEC"); }
{
	TypeId() [ Dims() ] ExpressionList() ";"
}

void ParameterList() : { }
{
	TypeId() < IDENTIFIER > [ "," TypeId() < IDENTIFIER > ]		
}

void MethodDeclaration() : { }
{
	( TypeId() | < VOID > ) < IDENTIFIER > "(" [ ParameterList() ] ")" "{"
		( ExpressionStatement() | VariableDeclaration() )*
	"}"
}

void ImplementsList() : { }
{
	< IMPLEMENTS > <IDENTIFIER > ( "," < IDENTIFIER >	)*
}

void ClassDefinition() : { }
{
	< CLASS > <IDENTIFIER > [ < EXTENDS > <IDENTIFIER > ] [ ImplementsList() ] "{"
	
	( Visibility() ( LOOKAHEAD(4) VariableDeclaration()
					| MethodDeclaration()
					| TupleDefinition() ) )*
    	
	"}"
}

void TupleDefinition() : { }
{
	< TUPLE > <IDENTIFIER > "{"
	
	( VariableDeclaration() )+
    	
	"}"
}

void ExceptionDefinition() : { }
{
	< EXCEPTION > <IDENTIFIER > [ < EXTENDS > <IDENTIFIER > ] "{"
	
	( Visibility() ( LOOKAHEAD(3) VariableDeclaration()
					| MethodDeclaration() ) )+
    	
	"}"
}

void ErrorDefinition() : { }
{
	< ERROR > <IDENTIFIER > [ < EXTENDS > <IDENTIFIER > ] "{"
	
	( Visibility() ( LOOKAHEAD(3) VariableDeclaration()
					| MethodDeclaration() ) )+
    	
	"}"
}


SimpleNode TranslationUnit() : { }
{
	( TupleDefinition() | ExceptionDefinition() | ErrorDefinition() )*
	ClassDefinition()
	{		return jjtn000;
	}
}

