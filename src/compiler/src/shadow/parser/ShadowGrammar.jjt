/*
 * Copyright Â© 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */

options {
  CACHE_TOKENS=true;
  JAVA_UNICODE_ESCAPE=true;
  STATIC=false;
  NODE_USES_PARSER=true;
  MULTI=true;
  VISITOR=true;
  VISITOR_EXCEPTION="ShadowException";
  VISITOR_DATA_TYPE="Boolean";
}

PARSER_BEGIN(ShadowParser)
package shadow.parser.javacc;

import java.io.*;
import shadow.parser.*;
import shadow.AST.ASTWalker;
import shadow.typecheck.type.Type;


/**
 * Grammar to parse Shadow
 * @author William R. Speirs & Barry Wittman
 */
public class ShadowParser
{
   /**
    * Class to hold modifiers.
    */
   static public final class ModifierSet
   {
     /* Definitions of the bits in the modifiers field.  */
     /* Unused Java modifiers are commented out until modifiers are finalized */ 
     public static final int PUBLIC         = 0x0001;
     public static final int PROTECTED      = 0x0002;
     public static final int PRIVATE        = 0x0004;
     public static final int ABSTRACT       = 0x0008;
     public static final int STATIC         = 0x0010;
     public static final int FINAL          = 0x0020;     
     public static final int NATIVE       	= 0x0040;     
     public static final int WEAK           = 0x0080;
     public static final int IMMUTABLE      = 0x0100;
     public static final int ASSIGNABLE   	= 0x0200;
     public static final int TYPE_NAME   	= 0x0400;
     public static final int FIELD		   	= 0x0800;


     /* Type Modifiers:
     	public		(only for inner classes)
     	private		(only for inner classes)
     	protected 	(only for inner classes)
		final 		(can't be extended)
		abstract		
		immutable	(final, abstract, and immutable are mutually exclusive)
     */


     /* Declaration Modifiers:
		public			(only for members)
     	private			(only for members)
     	protected 		(only for members)		
		static			(only for members)
		final 			(can't be changed)		
		weak			(reference will not stop GC)
		native          (used to map in C functions)
     */

     /* Hidden Modifiers: (used in the compiler internally, but cannot be marked by the user)
		assignable 		(used to mark variables [lvalues])
		type name		(used to distinguish between types and values/variables with that type, e.g. int vs. 5 or String vs. "figs")
		field			(used to mark nodes that are fields, as opposed to local variables, to inform the TAC [methods are NOT marked as fields])
     */
     

     /** A set of accessors that indicate whether the specified modifier
         is in the set. */

     public static boolean isPublic(int modifiers) { return (modifiers & PUBLIC) != 0; }
     public static boolean isProtected(int modifiers) { return (modifiers & PROTECTED) != 0; }
     public static boolean isPrivate(int modifiers) { return (modifiers & PRIVATE) != 0; }
     public static boolean isStatic(int modifiers) { return (modifiers & STATIC) != 0; }
     public static boolean isAbstract(int modifiers) { return (modifiers & ABSTRACT) != 0; }
     public static boolean isFinal(int modifiers) { return (modifiers & FINAL) != 0; }
     public static boolean isNative(int modifiers) { return (modifiers & NATIVE) != 0; }

     public static boolean isWeak(int modifiers) { return (modifiers & WEAK) != 0; }
     public static boolean isImmutable(int modifiers) { return (modifiers & IMMUTABLE) != 0; }
     public static boolean isAssignable(int modifiers) { return (modifiers & ASSIGNABLE) != 0; }
     public static boolean isTypeName(int modifiers) { return (modifiers & TYPE_NAME) != 0; }   
     public static boolean isField(int modifiers) { return (modifiers & FIELD) != 0; }     

     /**
      * Changes the given modifier.
      */
     public static int removeModifier(int modifiers, int mod) { return modifiers & ~mod; }
     public static int addModifier(int modifiers, int mod) { return modifiers | mod; }
     public static boolean hasModifier( int modifiers, int mod ) { return (modifiers & mod) != 0;     }
     public static int checkAndAdd( int modifiers, int mod ) throws ParseException
     {
       if( hasModifier( modifiers, mod ) ) throw new ParseException( "Repeated modifiers not allowed" );

       return addModifier( modifiers, mod );     }
   }

   private boolean debug = false;

   public ShadowParser(String fileName)
   {
      this(System.in);
      FileInputStream fis = null;
      
      try {
      	fis = new FileInputStream(new File(fileName));
        ReInit(fis);
      } catch(Exception e) {
        e.printStackTrace();
      } finally {      	try { fis.close(); }
      	catch(Exception e) { ; }      }
   }

    public void enableDebug() {
        debug = true;
    }
   	public void debugPrint(String str) {        if(debug)
            System.out.println("DEBUG: " + str + ": " + token);
    }
   	
  public static void main(String args[]) {
    try {
        String fileName = "src/shadow/typecheck/test/basic.shadow";
//        String fileName = "src/shadow/parser/test/statements/for.shadow";
        FileInputStream fis = new FileInputStream(fileName);        
        ShadowParser parser = new ShadowParser(fis);
        
//        parser.enableDebug();

        ASTCompilationUnit n = parser.CompilationUnit();

        n.dump("");

        System.out.println("GOOD PARSE");

    } catch (ParseException e) {
        System.out.println("BAD PARSE");
        System.out.println(e.getMessage());
    } catch (Error e) {
        System.out.println("ERROR");
        System.out.println(e.getMessage());
    } catch (FileNotFoundException e) {
        System.out.println(e.getMessage());
    } catch (Exception e) {
    	e.printStackTrace();    }      
  }

}

PARSER_END(ShadowParser)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < AND: "and" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CAST: "cast" >
| < CATCH: "catch" >
| < CLASS: "class" >
| < CODE: "code" >
| < CONSTRUCTOR: "constructor" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DELETE: "delete" >
| < DESTRUCTOR: "destructor" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < ERROR: "error" >
| < EXCEPTION: "exception" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FOREACH: "foreach" >
//| < GOTO: "goto" >
| < GET: "get" >
| < IF: "if" >
| < IMMUTABLE: "immutable" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < IN: "in" >
| < IS: "is" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < OR: "or" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SET: "set" >
| < SHORT: "short" >
| < STATIC: "static" >
//| < STRICTFP: "strictfp" >
| < STRING: "String" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
//| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < UBYTE: "ubyte" >
| < UINT: "uint" >
| < ULONG: "ulong" >
| < USHORT: "ushort" >
| < VIEW: "view" >
//| < VOLATILE: "volatile" >
| < WEAK: "weak" >
| < WHILE: "while" >
| < XOR: "xor" >
}

/* LITERALS */

TOKEN :
{
   < BYTE_LITERAL: //can't end with b or B because of hex digits
        <DECIMAL_LITERAL> ["y","Y"]
      | <HEX_LITERAL> ["y","Y"]
      | <OCTAL_LITERAL> ["y","Y"]
  >
|
  < UBYTE_LITERAL: //can't end with b or B because of hex digits
        <DECIMAL_LITERAL> ["u","U"]["y","Y"]
      | <HEX_LITERAL> ["u","U"]["y","Y"]
      | <OCTAL_LITERAL> ["u","U"]["y","Y"]
  >
|   
  < SHORT_LITERAL:
        <DECIMAL_LITERAL> ["s","S"]
      | <HEX_LITERAL> ["s","S"]
      | <OCTAL_LITERAL> ["s","S"]
  >  
|   
  < USHORT_LITERAL:
        <DECIMAL_LITERAL> ["u","U"]["s","S"]
      | <HEX_LITERAL> ["u","U"]["s","S"]
      | <OCTAL_LITERAL> ["u","U"]["s","S"]
  >  
|   
  < INT_LITERAL:
        <DECIMAL_LITERAL> (["i","I"])?
      | <HEX_LITERAL> (["i","I"])?
      | <OCTAL_LITERAL> (["i","I"])?
  >
| 
  < UINT_LITERAL:
        <DECIMAL_LITERAL> ["u","U"](["i","I"])?
      | <HEX_LITERAL> ["u","U"](["i","I"])?
      | <OCTAL_LITERAL> ["u","U"](["i","I"])?
  >  
|
  < LONG_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < ULONG_LITERAL:
        <DECIMAL_LITERAL> ["u","U"]["l","L"]
      | <HEX_LITERAL> ["u","U"]["l","L"]
      | <OCTAL_LITERAL> ["u","U"]["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOAT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["f","F"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      | (["0"-"9"])+ <EXPONENT> ["f","F"]
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < DOUBLE_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CODE_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|	
  < VERSION_LITERAL:  (["0"-"9"])+ "." (["0"-"9"])+ "." (["0"-"9"])+ >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
//       "\u0024",  // this is the $, but I want to use that for versions
       "\u0041"-"\u005a",       
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u005f", //underscore
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
//| < SC_OR: "||" >
//| < SC_AND: "&&" >
//| < INCR: "++" >
//| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < BIT_XOR: "^" >
| < REM: "%" >
| < LEFTSHIFT: "<<" >
| < LEFTROTATE: "<<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < REFASSIGN: "#=" >
| < LEFTSHIFTASSIGN: "<<=" >
| < RIGHTSHIFTASSIGN: ">>=" >
| < RIGHTROTATEASSIGN: ">>>=" >
| < LEFTROTATEASSIGN: "<<<=" >
| < VERSION: "$" >
//| < ELLIPSIS: "..." >
}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RIGHTROTATE: ">>>" >
  {
     matchedToken.kind = GT;
     ((GTToken)matchedToken).realKind = RIGHTROTATE;
     input_stream.backup(2); 
  }
| < RIGHTSHIFT: ">>" >
  { 
     matchedToken.kind = GT;
     ((GTToken)matchedToken).realKind = RIGHTSHIFT;
     input_stream.backup(1);
  }
| < GT: ">" >
}


/*****************************************
 * THE SHADOW LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTCompilationUnit CompilationUnit():
{}
{
  [ PackageDeclaration() ]
  ( ImportDeclaration() )*
  ( TypeDeclaration() )*
  <EOF>

	{
        return jjtThis;
	}
}

void PackageDeclaration():
{}
{
  "package" Name() ";"
}

void ImportDeclaration():
{}
{
  "import" [ "static" ] Name() [ ("." "*") | ("$" [">" | "<"] < VERSION_LITERAL >) ] ";"
}

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */

int Modifiers():
{
   int modifiers = 0;
   debugPrint("MODIFIERS");
}
{
 (
  LOOKAHEAD(2)
  (
    "public" { modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.PUBLIC); }
  | "static" { modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.STATIC); }
  | "protected" { modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.PROTECTED); }
  | "private" { modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.PRIVATE); }
  | "final" { modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.FINAL); }
  | "abstract" { modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.ABSTRACT); }
//  | "synchronized" { modifiers |= ModifierSet.SYNCHRONIZED; }
  | "native" { modifiers |= ModifierSet.NATIVE; }
//  | "transient" { modifiers |= ModifierSet.TRANSIENT; }
//  | "volatile" { modifiers |= ModifierSet.VOLATILE; }
//  | "strictfp" { modifiers |= ModifierSet.STRICTFP; }
  | "weak" { modifiers = ModifierSet.checkAndAdd( modifiers,  ModifierSet.WEAK); }
  |	"immutable"{ modifiers = ModifierSet.checkAndAdd( modifiers, ModifierSet.IMMUTABLE); }  | Annotation()
  )
 )*

 {
 	jjtThis.setModifiers(modifiers);
    return modifiers;
 }
}

/*
 * Declaration syntax follows.
 */
void TypeDeclaration():
{
   int modifiers;
   debugPrint("TYPE DECLARATION");
   
}
{
  ";"
| modifiers = Modifiers()
  ( ClassOrInterfaceDeclaration(modifiers)
  | EnumDeclaration(modifiers)
  | AnnotationTypeDeclaration(modifiers)
  | ViewDeclaration(modifiers)
  )
}

void ViewDeclaration(int modifiers):
{
	debugPrint("VIEW DECLARATION");
	Token t;
}
{
	"view" t = <IDENTIFIER> { jjtThis.setImage(t.image); jjtThis.setModifiers(modifiers);  }	"{"        
        ( ( LOOKAHEAD(PrimitiveType() "[") StaticArrayType() | PrimitiveType() ) VariableDeclaratorId() ";" )+
    "}"
}


void ClassOrInterfaceDeclaration(int modifiers):
{
   boolean isInterface = false;
   boolean isErrorOrException = false;
   debugPrint("CLASS OR INTERFACE DECLARARTION");
   Token t;
}
{
  { jjtThis.setModifiers(modifiers); }
  ( "class" { jjtThis.setKind(Type.Kind.CLASS);} 	| "exception" { jjtThis.setKind(Type.Kind.EXCEPTION); isErrorOrException = true; }
 	| "error" { jjtThis.setKind(Type.Kind.ERROR); isErrorOrException = true; }
 	| "interface" { jjtThis.setKind(Type.Kind.INTERFACE); isInterface = true; } )
  t = <IDENTIFIER> { jjtThis.setImage(t.image); jjtThis.setModifiers(modifiers); }
  [ Version() ]
  [ TypeParameters() ]
  [ ExtendsList(isInterface) ]
  [ ImplementsList(isInterface, isErrorOrException) ]
  ClassOrInterfaceBody(isInterface)
}

void ExtendsList(boolean isInterface):
{
   boolean extendsMoreThanOne = false;
   debugPrint("EXTENDS LIST");
}
{ 
   "extends" ClassOrInterfaceType()
   ( "," ClassOrInterfaceType() { extendsMoreThanOne = true; } )*
   {
      if (extendsMoreThanOne && !isInterface)
         throw new ParseException("A class cannot extend more than one other class");
   }
}

void ImplementsList(boolean isInterface, boolean isErrorOrException):
{ debugPrint("IMPLEMENTS"); }
{
   "implements" ClassOrInterfaceType()
   ( "," ClassOrInterfaceType() )*
   {
      if (isInterface)
         throw new ParseException("An interface cannot implement other interfaces");
      if( isErrorOrException )
      	throw new ParseException("An error or exception cannot implement interfaces");
   }
}

void Version():
{ debugPrint("VERSION"); }
{
   "$" < VERSION_LITERAL >
}

void EnumDeclaration(int modifiers):
{
    debugPrint("ENUM DECLARATION");
    Token t;
}
{
{ jjtThis.setModifiers(modifiers); }
  "enum" t = <IDENTIFIER> { jjtThis.setImage(t.image);  }
  [ ImplementsList(false,false) ]
  EnumBody()
}

void EnumBody():
{ debugPrint("ENUM BODY"); }
{
   "{"
   EnumConstant() ( "," EnumConstant() )*
   [ ";" ( ClassOrInterfaceBodyDeclaration(false) )* ]
   "}"
}

void EnumConstant():
{
	debugPrint("ENUM CONSTANT");
	Token t;
}
{
  t = <IDENTIFIER>  { jjtThis.setImage(t.image); } [ Arguments() ] [ ClassOrInterfaceBody(false) ]
}

void TypeParameters():
{ debugPrint("TYPE PARAMETERS"); }
{
   "<" TypeParameter() ( "," TypeParameter() )* ">"
}

void TypeParameter():
{
	debugPrint("TYPE PARAMETER");
	Token t;
}
{
   t = <IDENTIFIER>  { jjtThis.setImage(t.image); } [ TypeBound() ]
}

void TypeBound():
{ debugPrint("TYPE BOUND"); }
{
   "extends" ClassOrInterfaceType() ( "and" ClassOrInterfaceType() )*
}

void ClassOrInterfaceBody(boolean isInterface):
{ debugPrint("CLASS OR INTERFACE BODY"); }
{
  "{" ( ClassOrInterfaceBodyDeclaration(isInterface) )* "}"
}

void ClassOrInterfaceBodyDeclaration(boolean isInterface):
{
   boolean isNestedInterface = false;
   int modifier;
   debugPrint("CLASS OR INTERFACE BODY DECLARATION"); 
}
{
  LOOKAHEAD(2) Initializer() { if (isInterface) throw new ParseException("An interface cannot have initializers"); }
// Just get all the modifiers out of the way. If you want to do
// more checks, pass the modifiers down to the member  
| modifier = Modifiers()
  (  ClassOrInterfaceDeclaration(modifier)
    | EnumDeclaration(modifier)
    | LOOKAHEAD( [ TypeParameters() ] "constructor" ) ConstructorDeclaration(modifier)
    | LOOKAHEAD( "destructor" ) DestructorDeclaration(modifier)
    | LOOKAHEAD( Type() <IDENTIFIER> ( "," | "=" | ";" ) ) FieldDeclaration(modifier)
    //removed ( "[" "]" ) * because Shadow only allows square brackets on the LEFT of identifiers in declarations 
    | MethodDeclaration(modifier)
    | ViewDeclaration(modifier)
  )
| ";"
}

void FieldDeclaration(int modifiers):
{ debugPrint("FIELD DECLARATION"); }
{
  { jjtThis.setModifiers(modifiers); }
  Type() VariableDeclarator() ( "," VariableDeclarator() )* ";"
}

void VariableDeclarator():
{ debugPrint("VARIABLE DECLARATOR"); }
{
  VariableDeclaratorId() [ "=" VariableInitializer() ]
}

void VariableDeclaratorId():
{
    debugPrint("VARIABLE DECLARATOR ID");
    Token t;
}
{
  t = <IDENTIFIER> { jjtThis.setImage(t.image); }
  //( "[" "]" )*  Not in Shadow!
}

void VariableInitializer():
{ debugPrint("VARIABLE INITIALIZER"); }
{
  ArrayInitializer()
| Expression()
}

void ArrayInitializer():
{ debugPrint("ARRAY INITIALIZER"); }
{
  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"
}

void MethodDeclaration(int modifiers):
{ debugPrint("METHOD DECLARATION"); }
{
  { jjtThis.setModifiers(modifiers); }
  [ TypeParameters() ]
  MethodDeclarator() [ "throws" NameList() ]
  ( Block() | ";" )
}

void MethodDeclarator():
{
	debugPrint("METHOD DECLARATOR");
	Token t;
}
{
  t = <IDENTIFIER> { jjtThis.setImage(t.image); } FormalParameters() "=>" "(" [ ResultTypes() ] ")"
}

void FormalParameters():
{ debugPrint("FORMAL PARAMETERS"); }
{
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"
}

void FormalParameter():
{ debugPrint("FORMAL PARAMETER"); }
{
  [ "final" { jjtThis.addModifier(ModifierSet.FINAL); } ] Type() VariableDeclaratorId()
}

void ConstructorDeclaration(int modifiers):
{ debugPrint("CONSTRUCTOR DECLARATION"); }
{
  { jjtThis.setModifiers(modifiers); jjtThis.setImage("constructor"); }
  [ TypeParameters() ]
  // Modifiers matched in the caller
  "constructor" FormalParameters() [ "throws" NameList() ]
  "{"
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
    ( BlockStatement() )*
  "}"
}

void DestructorDeclaration(int modifiers):
{ debugPrint("DESTRUCTOR DECLARATION"); }
{
  { jjtThis.setModifiers(modifiers); jjtThis.setImage("destructor"); }
  //[ TypeParameters() ]
  // Modifiers matched in the caller
  "destructor" //[ "throws" NameList() ] //no (checked) exceptions from destructors!
  "{"    
    ( BlockStatement() )*
  "}"
}

void ExplicitConstructorInvocation():
{ debugPrint("EXPLICIT CONTRUCTOR INVOCATION"); }
{
  LOOKAHEAD("this" Arguments() ";")
  "this" Arguments() ";"
|
  [ LOOKAHEAD(2) PrimaryExpression() "." ] "super" Arguments() ";"
}

void Initializer():
{ debugPrint("INITIALIZER"); }
{
  [ "static" ] Block()
}


/*
 * Type, name and expression syntax follows.
 */

void Type():
{ debugPrint("TYPE"); }
{
   LOOKAHEAD(2) ReferenceType()
    |   LOOKAHEAD(PrimitiveType() "[") StaticArrayType()
    |   PrimitiveType()
    |	FunctionType()
}

void ReferenceType():
{ debugPrint("REFERENCE TYPE"); }
{
    PrimitiveType() ( LOOKAHEAD(2) "[" ( "," { jjtThis.incrementDimensions(); } )* { jjtThis.pushDimensions(); } "]" )+
  | ( ClassOrInterfaceType() ) ( LOOKAHEAD(2) "[" ( "," { jjtThis.incrementDimensions(); } )* { jjtThis.pushDimensions(); } "]" )*
}

void StaticArrayType():
{
	debugPrint("STATIC ARRAY TYPE");
	Token t;
}
{
    PrimitiveType() "[" IntegerLiteral() "]"
}



void FunctionType():
{
	debugPrint("FUNCTION TYPE");
}
{
    "(" [ Type() ( "," Type() )* ] ")" "=>" "(" [ ResultTypes() ] ")"
}

void ClassOrInterfaceType():
{
	debugPrint("CLASS OR INTERFACE TYPE");
	StringBuffer sb = new StringBuffer();
	Token t;
}
{
  t = <IDENTIFIER> { sb.append(t.image); }[ LOOKAHEAD(2) TypeArguments() ]
  ( LOOKAHEAD(2) "." t = <IDENTIFIER> { sb.append('.').append(t.image); } [ LOOKAHEAD(2) TypeArguments() ] )*
  { jjtThis.setImage(sb.toString()); }
}

void TypeArguments():
{ debugPrint("TYPE ARGUMENTS"); }
{
   "<" TypeArgument() ( "," TypeArgument() )* ">"
}

void TypeArgument():
{ debugPrint("TYPE ARGUMENT"); }
{
   ReferenceType()
 | "?" [ WildcardBounds() ]
}

void WildcardBounds():
{ debugPrint("WILDCARD BOUNDS"); }
{
   "extends" ReferenceType()
 | "super" ReferenceType()
}


void PrimitiveType():
{ debugPrint("PRIMITIVE TYPE"); }
{
  "boolean" { jjtThis.setType(Type.BOOLEAN); }
| "code"    { jjtThis.setType(Type.CODE); }
| "byte"    { jjtThis.setType(Type.BYTE); }
| "short"   { jjtThis.setType(Type.SHORT); }
| "int"     { jjtThis.setType(Type.INT); }
| "long"    { jjtThis.setType(Type.LONG); }
| "float"   { jjtThis.setType(Type.FLOAT); }
| "double"  { jjtThis.setType(Type.DOUBLE); }
| "String"  { jjtThis.setType(Type.STRING); }
| "ubyte"   { jjtThis.setType(Type.UBYTE); }
| "uint"    { jjtThis.setType(Type.UINT); }
| "ulong"   { jjtThis.setType(Type.ULONG); }
| "ushort"  { jjtThis.setType(Type.USHORT); }
}

void ResultType():
{ debugPrint("RESULT TYPE"); }
{
  Type()
}

void ResultTypes():
{ debugPrint("RESULT TYPES"); }
{
  ResultType() ( "," ResultType() )*
}

void Name():
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
	debugPrint("NAME");
	StringBuffer sb = new StringBuffer();
	Token t;
}
{
  t = <IDENTIFIER> { sb.append(t.image); debugPrint(t.image); } ( LOOKAHEAD(2) "." t = <IDENTIFIER> { sb.append('.').append(t.image); } )*
  { jjtThis.setImage(sb.toString()); }
}

void NameList():
{ debugPrint("NAME LIST"); }
{
  Name() ( "," Name() )*
}


/*
 * Expression syntax follows.
 */

void Expression():
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{ debugPrint("EXPRESSION"); }
{
  ConditionalExpression() [ LOOKAHEAD(2) AssignmentOperator() Expression() ]
}

void AssignmentOperator():
{ debugPrint("ASSIGNMENT OPERATOR"); }
{
    "="    { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.EQUAL); }
  | "#="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.REFASSIGN); }
  | "*="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.STARASSIGN); }
  | "/="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.SLASHASSIGN); }
  | "%="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.MODASSIGN); }
  | "+="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.PLUSASSIGN); }
  | "-="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.MINUSASSIGN); }
  | "<<="  { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.LEFTSHIFTASSIGN); }
  | ">>="  { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.RIGHTSHIFTASSIGN); }
  | ">>>=" { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.RIGHTROTATEASSIGN); }
  | "<<<=" { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.LEFTROTATEASSIGN); }
  | "&="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.ANDASSIGN); }
  | "^="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.XORASSIGN); }
  | "|="   { jjtThis.setAssignmentType(ASTAssignmentOperator.AssignmentType.ORASSIGN); }
}

void ConditionalExpression():
{}
{
  ConditionalOrExpression() [ "?" ConditionalExpression() ":" ConditionalExpression() ]
}

void ConditionalOrExpression():
{}
{
  ConditionalExclusiveOrExpression() ( "or" ConditionalExclusiveOrExpression() )*
}


void ConditionalExclusiveOrExpression():
{}
{
  ConditionalAndExpression() ( "xor" ConditionalAndExpression() )*
}

void ConditionalAndExpression():
{}
{
  BitwiseOrExpression() ( "and" BitwiseOrExpression() )*
}

void BitwiseOrExpression():
{}
{
  BitwiseExclusiveOrExpression() ( "|" { jjtThis.setImage(jjtThis.getImage() + "|"); } BitwiseExclusiveOrExpression() )*
}

void BitwiseExclusiveOrExpression():
{}
{
  BitwiseAndExpression() ( "^" { jjtThis.setImage(jjtThis.getImage() + "^"); } BitwiseAndExpression() )*
}

void BitwiseAndExpression():
{}
{
  EqualityExpression() ( "&" { jjtThis.setImage(jjtThis.getImage() + "&"); } EqualityExpression() )*
}

void EqualityExpression():
{}
{
  IsExpression() ( ( "==" { jjtThis.setImage("=="); } | "!=" { jjtThis.setImage("!="); } ) IsExpression() )*
}

void IsExpression():
{}
{
  RelationalExpression() [ "is" Type() ]
}

void RelationalExpression():
{ debugPrint("RELATIONAL EXPRESSION"); }
{
  ShiftExpression() ( ( "<" { jjtThis.setImage("<"); } |
                        ">" { jjtThis.setImage(">"); } |
                        "<=" { jjtThis.setImage("<="); } |
                        ">="  { jjtThis.setImage(">="); }) ShiftExpression() )*
}

//
// Since shift & rotate are not single characters (see TAC Symbole2Operator code)
// we are using r & l for right & left shift and
// R & L for right & left rotate
void ShiftExpression():
{ debugPrint("SHIFT EXPRESSION"); }
{
  RotateExpression()
  ( ( "<<" { jjtThis.setImage(jjtThis.getImage() + "l"); } |
      RightShift() { jjtThis.setImage(jjtThis.getImage() + "r"); } ) RotateExpression() )*
}

void RotateExpression():
{ debugPrint("ROTATE EXPRESSION"); }
{
  AdditiveExpression()
  ( ( "<<<" { jjtThis.setImage(jjtThis.getImage() + "L"); } |
      RightRotate() { jjtThis.setImage(jjtThis.getImage() + "R"); } ) AdditiveExpression() )*
}

//
// There is a parsing issue here when we have expressions like 1 + 2 - 3 + 4
// This will come back as everything being +
// So as a complete hack I'm creating a string of symbols for each pair of expressions
//
void AdditiveExpression():
{}
{
  MultiplicativeExpression()
  ( ( "+" { jjtThis.setImage(jjtThis.getImage() + "+"); } |
      "-" { jjtThis.setImage(jjtThis.getImage() + "-"); } ) MultiplicativeExpression() )*
}

void MultiplicativeExpression():
{}
{
  UnaryExpression()
  ( ( "*" { jjtThis.setImage(jjtThis.getImage() + "*"); } |
      "/" { jjtThis.setImage(jjtThis.getImage() + "/"); } |
      "%" { jjtThis.setImage(jjtThis.getImage() + "%"); } ) UnaryExpression() )*
}

void UnaryExpression():
{}
{
  ( "+" { jjtThis.setImage("+"); } | "-" { jjtThis.setImage("-"); } ) UnaryExpression()
| UnaryExpressionNotPlusMinus()
}

void UnaryExpressionNotPlusMinus():
{ debugPrint("UNARY EXPRESSION NOT PLUS MINUS"); }
{
  ( "~" { jjtThis.setImage("~"); } | "!" { jjtThis.setImage("!"); } ) UnaryExpression()
| CastExpression()
| PrimaryExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
//void CastLookahead()://{ debugPrint("CAST LOOKAHEAD"); }//{//  LOOKAHEAD(2)//  "(" PrimitiveType()//|//  LOOKAHEAD("(" Type() "[")//  "(" Type() "[" "]"//|//  "(" Type() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )//}

void CastExpression():
{
    debugPrint("CAST EXPRESSION");
    jjtThis.setImage("cast< >");   
}
{
  LOOKAHEAD("cast" "<" PrimitiveType()) "cast" "<" Type() ">" UnaryExpression()
| "cast" "<" Type() ">" UnaryExpressionNotPlusMinus()
}

void PrimaryExpression():
{ debugPrint("PRIMARY EXPRESSION"); }
{
 	  AllocationExpression()
	| PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )* [ LOOKAHEAD(2) "." AllocationExpression() ]
}

void Sequence():
{ debugPrint("SEQUENCE"); }
{	"(" ConditionalExpression() ("," ConditionalExpression() )* ")"
}

void MethodCall():
{	debugPrint("METHOD CALL");
	Token t;
}
{    t = <IDENTIFIER> { jjtThis.setImage(t.image); } "(" [ ConditionalExpression() ( "," ConditionalExpression() )* ] ")"
}

void PrimaryPrefix():
{
	debugPrint("PRIMARY PREFIX");
	Token t;
}
{
  Literal()
| "this" { jjtThis.setImage("this"); }
| "super" "." t = <IDENTIFIER> { jjtThis.setImage("super." + t.image); }
| LOOKAHEAD( "(" ConditionalExpression() ")" ) "(" ConditionalExpression() ")"
| LOOKAHEAD( ResultType() "." "class" ) ResultType() "." "class"
//| TypeArguments() t = <IDENTIFIER> { jjtThis.setImage(t.image); } MethodCall()
| LOOKAHEAD(2) MethodCall()
| t = <IDENTIFIER> { jjtThis.setImage(t.image); debugPrint(t.image); }
}

void PrimarySuffix():
{
	debugPrint("PRIMARY SUFFIX");
	Token t;
}
{
  LOOKAHEAD(2) "." "this" { jjtThis.setImage("this"); } // when does this even happen?
| "[" ConditionalExpression() ("," ConditionalExpression())* "]"
//| "." TypeArguments() t = <IDENTIFIER> { jjtThis.setImage(t.image); } MethodCall()
| LOOKAHEAD(3) "." MethodCall()
| "." t = <IDENTIFIER> { jjtThis.setImage(t.image); debugPrint(t.image); }
}

void Literal() :
{
	debugPrint("LITERAL");
	Token t;
	jjtThis.addModifier(ModifierSet.FINAL); 
}
{
  (    
  t = <BYTE_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.BYTE); }
| t = <CODE_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.CODE); }
| t = <SHORT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.SHORT); }
| t = <INT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.INT); }
| t = <LONG_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.LONG); }
| t = <FLOAT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.FLOAT); }
| t = <DOUBLE_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.DOUBLE); }
| t = <STRING_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.STRING); }
| t = <UBYTE_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.UBYTE); }
| t = <USHORT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.USHORT); }
| t = <UINT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.UINT); }
| t = <ULONG_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.ULONG); }
| BooleanLiteral() { jjtThis.setType(Type.BOOLEAN); }
| NullLiteral() { jjtThis.setType(Type.NULL); }  )
  
  //what about longs, shorts, floats, unsigned versions etc.?
 /* OLD:
  t = <INTEGER_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.INT); }
| t = <FLOATING_POINT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.DOUBLE); }
| t = <CODE_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.CODE); }
| t = <STRING_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.STRING); }
| BooleanLiteral() { jjtThis.setType(Type.BOOLEAN); }
| NullLiteral() { jjtThis.setType(Type.NULL); }
*/
}


void IntegerLiteral(): //useful for static arrays, etc.
{
	debugPrint("INTEGER LITERAL");
	Token t;
}
{
     (
		  t = <BYTE_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.BYTE); }
		| t = <UBYTE_LITERAL > { jjtThis.setImage(t.image); jjtThis.setType(Type.UBYTE); }
		| t = <SHORT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.SHORT); }
		| t = <USHORT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.USHORT); }
		| t = <INT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.INT); }
		| t = <UINT_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.UINT); }
		| t = <LONG_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.LONG); }
		| t = <ULONG_LITERAL> { jjtThis.setImage(t.image); jjtThis.setType(Type.ULONG); }
	)
}

void BooleanLiteral():
{ debugPrint("BOOLEAN LITERAL"); }
{    
  "true" { jjtThis.setTrue(); }
| "false"
 
}

void NullLiteral():
{ debugPrint("NULL LITERAL"); }
{
  "null"
}

void Arguments():
{ debugPrint("ARGUMENTS"); }
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList():
{ debugPrint("ARGUMENT LIST"); }
{
  ConditionalExpression() ( "," ConditionalExpression() )*
}

void AllocationExpression():
{ debugPrint("ALLOCATION EXPRESSION"); }
{
  LOOKAHEAD(2)
  "new" { jjtThis.setImage("new"); } PrimitiveType() ArrayDimsAndInits()
| "new" { jjtThis.setImage("new"); } ClassOrInterfaceType() [ TypeArguments() ]
    (
      ArrayDimsAndInits()
    | Arguments() /* No anonymous classes in Shadow [ ClassOrInterfaceBody(false)  ] */
    )
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits():
{ debugPrint("ARRAY DIMS AND INITS"); }
{
  LOOKAHEAD(2)( LOOKAHEAD(2) "[" ConditionalExpression() ("," ConditionalExpression() { jjtThis.incrementDimensions();} )* { jjtThis.pushDimensions();}  "]" )+ ( LOOKAHEAD(2) "[" (",")* "]" )*
| ( "[" (","{ jjtThis.incrementDimensions(); })* "]" { jjtThis.pushDimensions(); } )+ ArrayInitializer()
}


/*
 * Statement syntax follows.
 */

void Statement():
{ debugPrint("STATEMENT"); }
{
  LOOKAHEAD(2) LabeledStatement()
| AssertStatement()
| Block()
| EmptyStatement()
| StatementExpression() ";"
| SwitchStatement()
| IfStatement()
| WhileStatement()
| DoStatement()
| ForStatement()
| ForeachStatement()
| BreakStatement()
| ContinueStatement()
| ReturnStatement()
| ThrowStatement()
| SynchronizedStatement()
| TryStatement()
}

void AssertStatement():
{ debugPrint("ASSERT STATEMENT"); }
{
  "assert" ConditionalExpression() [ ":" ConditionalExpression() ] ";"
}

void LabeledStatement():
{
	Token t;
}
{
  t = <IDENTIFIER> { jjtThis.setImage(t.image); } ":" Statement()
}

void Block():
{ debugPrint("BLOCK"); }
{
  "{" ( BlockStatement() )* "}"
}

void BlockStatement():
{
    debugPrint("BLOCK STATEMENT");
}
{
  LOOKAHEAD([ "final" ] Type() <IDENTIFIER> ) LocalVariableDeclaration() ";"
| Statement()
//| ClassOrInterfaceDeclaration(0)  No local classes in Shadow
}

void LocalVariableDeclaration():
{ debugPrint("LOCAL VARIABLE DECLARATION"); }
{
  [ "final" { jjtThis.addModifier(ModifierSet.FINAL); } ] Type() VariableDeclarator() ( "," VariableDeclarator() )*
}

void EmptyStatement():
{}
{
  ";"
}

void StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Shadow expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{ debugPrint("STATEMENT EXPRESSION"); }
{
  	//Looks like hell, but sequence expansions are either:
  	//Sequence() = Sequence() = ... = Sequence() = Sequence() or
  	//Sequence() = Sequence() = ... = Sequence() = PrimaryExpression() [for method calls] 
  	  LOOKAHEAD( Sequence() ) (LOOKAHEAD( Sequence() "=" ) Sequence() "=" )+ ( LOOKAHEAD( Sequence() ) Sequence() | PrimaryExpression() )
	| PrimaryExpression() [ AssignmentOperator() Expression() ]
}

void SwitchStatement():
{ debugPrint("SWITCH STATEMENT"); }
{
  "switch" "(" ConditionalExpression() ")" "{"
    ( SwitchLabel() ( BlockStatement() )* )*
  "}"
}

void SwitchLabel():
{}
{
  "case" ConditionalExpression() ":"
|
  "default" ":"
}

void IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{ debugPrint("IF STATEMENT"); }
{
  "if" "(" ConditionalExpression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
}

void WhileStatement():
{ debugPrint("WHILE STATEMENT"); }
{
  "while" "(" ConditionalExpression() ")" Statement()
}

void DoStatement():
{ debugPrint("DO STATEMENT"); }
{
  "do" Statement() "while" "(" ConditionalExpression() ")" ";"
}

void ForeachStatement():
{
	debugPrint("FOREACH STATEMENT");
	Token t;
}
{
  "foreach" "(" Type() t = <IDENTIFIER> { jjtThis.setImage(t.image); } "in" ConditionalExpression() ")" Statement()
}


void ForStatement() :
{ debugPrint("FOR STATEMENT"); }
{
  "for" "(" [ ForInit() ] ";" ConditionalExpression() ";" [ ForUpdate() ] ")" Statement()
}

void ForInit():
{
	debugPrint("FOR INIT");
	Token t;
}
{
  LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> ) LocalVariableDeclaration()
| StatementExpressionList()
}

void StatementExpressionList():
{ debugPrint("STATEMENT EXPRESSION LIST"); }
{
  StatementExpression() ( "," StatementExpression() )*
}

void ForUpdate():
{ debugPrint("FOR UPDATE"); }
{
  StatementExpressionList()
}

void BreakStatement():
{
	Token t;
	debugPrint("BREAK STATEMENT");
	jjtThis.setImage("");
}
{
  "break" [t = <IDENTIFIER> { jjtThis.setImage(t.image); } ] ";"
}

void ContinueStatement():
{ debugPrint("CONTINUE STATEMENT"); }
{
  "continue" ";"
}

void ReturnStatement():
{ debugPrint("RETURN STATEMENT"); }
{
  "return"  ( ";"
  | LOOKAHEAD(Sequence()) Sequence() ";"
  |  ConditionalExpression() ";"   
  )
}

void ThrowStatement():
{ debugPrint("THROW STATEMENT"); }
{
  "throw" ConditionalExpression() ";"
}

void SynchronizedStatement():
{}
{
  "synchronized" "(" ConditionalExpression() ")" Block()
}

void TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{ debugPrint("TRY STATEMENT"); }
{
  "try" Block()
  ( "catch" "(" FormalParameter() ")" Block() )*
  [ "finally" Block() ]
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RightRotate():
{ debugPrint("RIGHT ROTATE"); }
{
  ( LOOKAHEAD({ getToken(1).kind == GT && ((GTToken)getToken(1)).realKind == RIGHTROTATE} ) ">" ">" ">" )
}


void RightShift():
{ debugPrint("RIGHT SHIFT"); }
{
  ( LOOKAHEAD({ getToken(1).kind == GT && ((GTToken)getToken(1)).realKind == RIGHTSHIFT} ) ">" ">" )
}

/* Annotation syntax follows. */

void Annotation() #void:
{}
{
   LOOKAHEAD( "@" Name() "(" ( <IDENTIFIER> "=" | ")" ))
   NormalAnnotation()
 |
   LOOKAHEAD( "@" Name() "(" )
   SingleMemberAnnotation()
 |
   MarkerAnnotation()
}

void NormalAnnotation() #void:
{}
{
   "@" Name() "(" [ MemberValuePairs() ] ")"
}

void MarkerAnnotation() #void:
{}
{
  "@" Name()
}

void SingleMemberAnnotation() #void:
{}
{
  "@" Name() "(" MemberValue() ")"
}

void MemberValuePairs():
{ debugPrint("MEMBER VALUE PAIRS"); }
{
   MemberValuePair() ( "," MemberValuePair() )*
}

void MemberValuePair():
{
	debugPrint("MEMBER VALUE PAIR");
	Token t;
}
{
    t = <IDENTIFIER> { jjtThis.setImage(t.image); } "=" MemberValue()
}

void MemberValue():
{ debugPrint("MEMBER VALUE"); }
{
   Annotation()
 | MemberValueArrayInitializer()
 | ConditionalExpression()
}

void  MemberValueArrayInitializer():
{ debugPrint("MEMBER VALUE ARRAY INITIALIZER"); }
{
  "{" MemberValue() ( LOOKAHEAD(2) "," MemberValue() )* [ "," ] "}"
}


/* Annotation Types. */

void AnnotationTypeDeclaration(int modifiers) #void:
{ debugPrint("ANNOTATION TYPE DECLARATION"); }
{
  "@" "interface" <IDENTIFIER> AnnotationTypeBody()
}

void AnnotationTypeBody() #void:
{ debugPrint("ANNOTATION TYPE BODY"); }
{
  "{" ( AnnotationTypeMemberDeclaration() )* "}"
}

void AnnotationTypeMemberDeclaration() #void:
{
   int modifiers;
   debugPrint("ANNOTATION TYPE MEMBER DECLARATION"); 
}
{
 modifiers = Modifiers()
 (
   LOOKAHEAD(Type() <IDENTIFIER> "(")
    Type() <IDENTIFIER> "(" ")" [ DefaultValue() ] ";"
  | ClassOrInterfaceDeclaration(modifiers)
  | EnumDeclaration(modifiers)
  | AnnotationTypeDeclaration(modifiers)
  | FieldDeclaration(modifiers)
 )
 |
   ( ";" )
}

void DefaultValue():
{ debugPrint("DEFAULT VALUE"); }
{
  "default" MemberValue()
}
