The static keyword is gone.

Constants are implicitly static.
There is only ever one of a singleton class (per thread), but you have to get it through the instance keyword.

There are three kinds of members in Shadow:

Constants
Fields
Methods

Constants are always public, final, and immutable (no modifiers!).  They are accessed with Class:CONSTANT.

Fields are always private (no modifier), are optionally final, immutable, get, set.  They are accessed inside the class only as member or this:member for disambiguation.
Fields can be final (must point at the same thing) and/or immutable (contents cannot be altered).


Methods must be private, public, or protected.  And optionally shared, final, immutable, {get ^ set}.  They are accessed with object.method() or Class.method() (shared).
Methods can be final (cannot be overridden) and/or immutable (cannot change the contents of the object).

constant is the keyword for constants.

Classes can be immutable meaning that all members are immutable and methods are immutable.
Immutable classes cannot be subclassed.
Immutable methods cannot be overridden.

immutable
for classes means everything is immutable and cannot be subclassed
for methods means "this" is immutable and cannot be overridden
for local references, means readonly, and there are no non-readonly references
for field references, it is the same, but also can only be assigned once

readonly
for references, means only readonly and immutable methods can be called
for methods, it means "this" is readonly
for classes means everything is readonly (and can be subclassed)


immutable Wombat x = new Wombat();
immutable function(int a) => ()
{

}

function(int a) => (immutable Wombat)
{

}

int immutable[] a  = new int[15];

Wombat immutable[] immutable[] a  = new Wombat [15][20];
Wombat [] immutable[] a  = new Wombat[15][20];

immutable Array<Wombat>
Array<immutable Wombat>

final Wombat[] wombats = ...; // wombats = is invalid

immutable Array<Wombat>
immutable Wombat[] wombats = ...; // wombats[i] = is invalid

Array<immutable Wombat>
Wombat immutable [] wombats = ...; // wombats[i].eat() = is invalid


Array<immutable Array<immutable Wombat>>

==

auto x = new SpecialCollection<immutable Wombat>();


immutable Collection<Wombat> w = new Collection<Wombat>();


Getters and setters

Methods with the modifier get must have type () => (Type)
Methods with the modifier set must have type (Type) => ()

Getters and setters cannot be overloaded.... or can they?

If a field has a get modifier and there are no getters with that name, then the class gets this method for free:
immutable get name() => (immutable Type) {
	return name;
}

If a field has a set modifier and there are no setters with that name, then the class gets this method for free:
set name(Type value) => () {
	name = value;
} 
