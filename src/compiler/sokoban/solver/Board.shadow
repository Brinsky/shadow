import shadow.utility@List;
import shadow.utility@Set;
import shadow.utility@Queue;
import shadow.utility@ArrayList;

class sokoban.solver@Board {
	constant int MAX = 256;
	constant code FLOOR = ' ', WALL = '#', TARGET = '.';
	constant ushort[] EMPTY = ushort:create[0];
	ushort width, height, boxCount;
	code[] board;
	State initial;
	Set<State> stateSet;
	public create(List<String> rows, int cols) {
		if (cols <= 0 or cols >= MAX or rows.size() <= 0 or rows.size() >= MAX or (cols == MAX and rows.size() == MAX))
			throw IllegalArgumentException:create("Invalid size");
		width = cast<ushort>cols;
		height = cast<ushort>rows.size();
		ushort boxes = 0, targets = 0;
		for (int row = 0; row < height; row += 1)
			for (int col = 0; col < width; col += 1)
				if (rows[row]->size > col)
					switch (rows[row][col]) {
						case ('$', 'o') {
							boxes += 1;
						} case ('+', '.') {
							targets += 1;
						} case ('*') {
							boxes += 1;
							targets += 1;
						}
					}
		if (boxes != targets)
			throw IllegalArgumentException:create("# boxes != # targets");
		if (boxes >= MAX * MAX - 1)
			throw IllegalArgumentException:create("Too many boxes");
		boxCount = boxes;
		board = code:create[width * height];
		State first = State:create();
		foreach (Coordinate coord in first) {
			if (rows[coord.getRow()]->size <= coord.getCol())
				coord.setFloor();
			else switch (rows[coord.getRow()][coord.getCol()]) {
				case ('#') {
					coord.setWall();
				} case (' ') {
					coord.setFloor();
				} case ('.') {
					coord.setFloor();
					coord.setTarget();
				} case ('$', 'o') {
					coord.setFloor();
					coord.addBox();
				} case ('*') {
					coord.setFloor();
					coord.setTarget();
					coord.addBox();
				} case ('@') {
					coord.setFloor();
					coord.setPlayer();
				} case ('+') {
					coord.setTarget();
					coord.setPlayer();
				} default {
					throw IllegalArgumentException:create();
				}
			}
		}
		stateSet = HashSet<State>:create();
		initial = first.initialize();
	}

	public immutable getInitialState() => (State) {
		return initial;
	}
	public immutable getStates() => (Set<State>) {
		return stateSet;
	}
	public immutable toString() => (String) {
		return initial.toString();
	}

	public class State implements CanCompare<State>, CanIterate<Coordinate> {
		int depth;
		State parent;
		ushort[][] state;
		private create() {
			depth = 0;
			parent = null;
			state = ushort:create[2][];
			state[0] = ushort:create[boxCount + 1];
			for (int i = 1; i <= boxCount; i += 1)
				state[0][i] = 0xffff;
			state[1] = ushort:create[1];
		}
		private create(State other, Coordinate player) {
			depth = other.depth + 1;
			parent = other;
			state = ushort:create[2][];
			state[0] = ushort:create[boxCount + 1];
			System.arraycopy(other.state[0], 0, state[0], 0, boxCount + 1);
			state[1] = ushort:create[1];
			state[1][0] = player.index;
		}

		private initialize(Queue<Coordinate> queue, Coordinate last, Coordinate coord) => () {
			if (!coord.isWall() and !coord.hasBox() and coord.getDistance() == -1) {
				coord.setDistance(last.getDistance() + 1);
				queue.add(coord);
			}
		}
		private initialize() => (State) {
			Queue<Coordinate> queue = ArrayDeque<Coordinate>:create();
			queue.add(getPlayer());
			while (!queue.isEmpty()) {
				Coordinate last = queue.remove();
				foreach (Coordinate coord in last)
					initialize(queue, last, coord);
			}
			return stateSet.add(this) ? this, null;
		}

		public immutable getMaxDistance() => (int) {
			return state->size - 2;
		}
		public immutable getNumCoordinates(int dist) => (int) {
			return state[dist + 1]->size;
		}
		public immutable getCoordinate(int dist, int num) => (Coordinate) {
			return Coordinate:create(state[dist + 1][num]);
		}
		public immutable getPlayer() => (Coordinate) {
			return getCoordinate(0, 0);
		}
		public immutable getBoxes() => (CanIterate<Coordinate>) {
			return BoxIterable:create();
		}
		private immutable class BoxIterable implements CanIterate<Coordinate> {
			public immutable iterator() => (Iterator<Coordinate>) {
				return BoxIterator:create();
			}
		}
		private class BoxIterator implements Iterator<Coordinate> {
			ushort index = 0;
			public immutable hasNext() => (boolean) {
				return index < state[0][0];
			}
			public next() => (Coordinate) {
				if (index >= state[0][0])
					throw NoSuchElementException:create();
				return Coordinate:create(state[0][++index]);
			}
		}

		public immutable isLosing(Coordinate box) => (boolean) {
			if (!box.isTarget()) {
				if (box.moveUp().isWall() and box.moveRight().isWall())
					return true;
				if (box.moveRight().isWall() and box.moveDown().isWall())
					return true;
				if (box.moveDown().isWall() and box.moveLeft().isWall())
					return true;
				if (box.moveLeft().isWall() and box.moveUp().isWall())
					return true;
				if (box.moveUp().isFull() and box.moveRight().isFull() and box.moveUpRight().isFull())
					return true;
				if (box.moveRight().isFull() and box.moveDown().isFull() and box.moveDownRight().isFull())
					return true;
				if (box.moveDown().isFull() and box.moveLeft().isFull() and box.moveDownLeft().isFull())
					return true;
				if (box.moveLeft().isFull() and box.moveUp().isFull() and box.moveUpLeft().isFull())
					return true;
			}
			if (box.moveLeft().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveLeft().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveUp();
				}
				current = box.moveDown();
				while (!current.isWall() and wall) {
					if (!current.moveLeft().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveDown();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (box.moveRight().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveRight().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveUp();
				}
				current = box.moveDown();
				while (!current.isWall() and wall) {
					if (!current.moveRight().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveDown();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (box.moveUp().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveUp().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveRight();
				}
				current = box.moveLeft();
				while (!current.isWall() and wall) {
					if (!current.moveUp().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveLeft();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (box.moveDown().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveDown().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveRight();
				}
				current = box.moveLeft();
				while (!current.isWall() and wall) {
					if (!current.moveDown().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveLeft();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (isUnreachableArea(box.moveUpLeft(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveUp(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveUpRight(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveRight(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveDownRight(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveDown(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveDownLeft(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveLeft(), HashSet<Coordinate>:create()))
				return true;
			return false;
		}
		private immutable isUnreachableArea(Coordinate center, Set<Coordinate> area) => (boolean) {
			if (center.isTarget() or center.isFull() or center.isReachable())
				return false;
			if (!area.add(center))
				return true;
			foreach (Coordinate coord in center)
				if (coord.isEmpty() and !isUnreachableArea(coord, area))
					return false;
			foreach (Coordinate coord in center)
				if (coord.hasBox() and !center.over(coord).isWall() and !coord.over(center).isWall() and !area.contains(center.over(coord)))
					return false;
			if (center.moveUpLeft().isEmpty() and !area.contains(center.moveUpLeft())) {
				if (center.moveUp().hasBox() and center.moveUpRight().isEmpty())
					return false;
				if (center.moveLeft().hasBox() and center.moveDownLeft().isEmpty())
					return false;
			}
			if (center.moveUpRight().isEmpty() and !area.contains(center.moveUpRight())) {
				if (center.moveUp().hasBox() and center.moveUpLeft().isEmpty())
					return false;
				if (center.moveRight().hasBox() and center.moveDownRight().isEmpty())
					return false;
			}
			if (center.moveDownLeft().isEmpty() and !area.contains(center.moveDownLeft())) {
				if (center.moveDown().hasBox() and center.moveDownRight().isEmpty())
					return false;
				if (center.moveLeft().hasBox() and center.moveUpLeft().isEmpty())
					return false;
			}
			if (center.moveDownRight().isEmpty() and !area.contains(center.moveDownRight())) {
				if (center.moveDown().hasBox() and center.moveDownLeft().isEmpty())
					return false;
				if (center.moveRight().hasBox() and center.moveUpRight().isEmpty())
					return false;
			}
			return true;
		}
		public immutable isWinning() => (boolean) {
			foreach (Coordinate coord in getBoxes())
				if (!coord.isTarget())
					return false;
			return true;
		}
		public immutable tryMove(Coordinate from, Coordinate to) => (State) {
			if (!to.hasBox())
				return null;
			Coordinate next = from.over(to);
			if (next.isWall() or next.hasBox())
				return null;
			State state = State:create(this, to);
			state.getPlayer().removeBox();
			Coordinate box = state.Coordinate:create(next).addBox();
			state = state.initialize();
			if (state == null or state.isLosing(box))
				return null;
			stateQueue.add(this);
			return state;
		}
		public move(Coordinate from, Coordinate to) => (State) {
			State state = State:create(this, to);
			if (to.hasBox()) {
				Coordinate next = from.over(to);
				if (next.isWall() or next.hasBox())
					return null;
				state.getPlayer().removeBox();
				state.Coordinate:create(next).addBox();
			}
			return state;
		}
		public getPath(MutableString sb, Coordinate from, Coordinate to) => (MutableString) {
			while (!to.equals(from))
				to = getMove(sb, to);
			return sb;
		}
		public getMove(MutableString sb, Coordinate to) => (Coordinate) {
			int index = 0;
			foreach (Coordinate from in to) {
				if (from.getDistance() == to.getDistance() - 1) {
					sb.append("DURL"[index]);
					return from;
				}
				index += 1;
			}
			throw Error:create("Where did I come from?");
		}

		public compare(State other) => (int) {
			return depth - other.depth;
		}
		public equals(Object other) => (boolean) {
			if (!(other is State))
				return false;
			if (state[0] != cast<State>(other).state[0])
				return false;
			foreach (Coordinate otherCoord in cast<State>other) {
				Coordinate thisCoord = Coordinate:create(otherCoord);
				if (thisCoord.hasBox() != otherCoord.hasBox() or
						thisCoord.isReachable() != otherCoord.isReachable())
					return false;
			}
			return true;
		}
		public hashCode() => (int) {
			int hash = 0;
			for (int i = 0; i < state.length; i += 1) {
				if (i == 1)
					hash <<= 16;
				for (int j = 0; j < state[i].length; j += 1)
					hash ^= state[i][j];
			}
			return hash;
		}
		public toString() => (String) {
			MutableString sb = MutableString:create();
			for (int row = 0; row < height; row += 1) {
				for (int col = 0; col < width; col += 1) {
					Coordinate coord = Coordinate:create(row, col);
					if (coord.isWall())
						sb.append('#');
					else if (coord.hasPlayer())
						sb.append('@');
					else if (coord.isTarget() and coord.hasBox())
						sb.append('*');
					else if (coord.hasBox())
						sb.append('o');
					else if (coord.isTarget())
						sb.append('.');
					else
						sb.append(' ');
				}
				/*sb.append(" | ");
				for (int col = 0; col < width; col += 1) {
					Coordinate coord = new Coordinate(row, col);
					if (coord.isWall())
						sb.append("##");
					else if (coord.hasBox())
						sb.append("[]");
					else if (coord.getDistance() < 0)
						sb.append("  ");
					else
						sb.append(String.format("%02d", coord.getDistance()));
				}*/
				sb.append(System.getProperty("line.separator"));
			}
			return sb.toString();
		}

		public class Coordinate implements CanCompare<Coordinate>, CanIterate<Coordinate> {
			ushort index;
			private create() {
				index = 0;
			}
			private create(int i) {
				if (i >= board.length)
					throw IllegalArgumentException:create();
				index = cast<ushort>i;
			}
			private create(int row, int col) {
				this(row * width + col);
			}
			public create(Coordinate other) {
				this(other.getRow(), other.getCol());
			}

			private next() => (Coordinate) {
				try {
					return Coordinate:create(index + 1);
				} catch (IllegalArgumentException ex) {
					return null;
				}
			}
			private over(Coordinate next) => (Coordinate) {
				try {
					return Coordinate:create(2 * next.getRow() - getRow(), 2 * next.getCol() - getCol());
				} catch (IllegalArgumentException ex) {
					return null;
				}
			}
			private away(Coordinate from) => (Coordinate) {
				return from.over(this);
			}
			private findBox() => (int) {
				ushort[] boxes = state[0];
				int value = index, min = 1, max = boxes[0];
				while (min <= max) {
					int mid = (min + max) >>> 1;
					if (boxes[mid] < value)
						min = mid + 1;
					else if (boxes[mid] > value)
						max = mid - 1;
					else
						return mid;
				}
				return max;
			}

			private setFloor() => () {
				board[index] = FLOOR;
			}
			private setWall() => () {
				board[index] = WALL;
			}
			private setTarget() => () {
				board[index] = TARGET;
			}
			private addBox() => (Coordinate) {
				ushort[] boxes = state[0];
				int loc = findBox();
				if (boxes[loc] != index) {
					loc += 1;
					boxes[0] += 1;
					System.arraycopy(boxes, loc, boxes, loc + 1, boxes[0] - loc);
					boxes[loc] = index;
				}
				return this;
			}
			private removeBox() => (Coordinate) {
				ushort[] boxes = state[0];
				int loc = findBox();
				if (boxes[loc] == index) {
					System.arraycopy(boxes, loc + 1, boxes, loc, boxes[0] - loc);
					boxes[boxes[0]] = 0xffff;
					boxes[0] -= 1;
				}
				return this;
			}
			private setPlayer() => () {
				state[1][0] = index;
			}
			private setDistance(int dist) => () {
				if (++dist > 0) {
					if (dist >= state.length) {
						ushort[][] newState = ushort:create[dist + 1][];
						System.arraycopy(state, 0, newState, 0, state.length);
						for (int i = state.length; i <= dist; i += 1)
							newState[i] = EMPTY;
						state = newState;
					}
					ushort[] oldArray = state[dist], newArray = ushort:create[oldArray.length + 1];
					System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);
					newArray[oldArray.length] = index;
					state[dist] = newArray;
				}
			}
			private getDistance() => (int) {
				for (int dist = 1; dist < state.length; dist += 1)
					for (int i = 0; i < state[dist].length; i += 1)
						if (state[dist][i] == index)
							return dist - 1;
				return -1;
			}
			private isReachable() => (boolean) {
				return getDistance() != -1;
			}

			public getRow() => (int) {
				return index / width;
			}
			public getCol() => (int) {
				return index % width;
			}
			public isFloor() => (boolean) {
				return board[index] == FLOOR;
			}
			public isWall() => (boolean) {
				return board[index] == WALL;
			}
			public isTarget() => (boolean)  {
				return board[index] == TARGET;
			}
			public hasBox() => (boolean) {
				ushort[] boxes = state[0];
				int value = index, min = 1, max = boxes[0];
				while (min <= max) {
					int mid = (min + max) >>> 1;
					if (boxes[mid] < value)
						min = mid + 1;
					else if (boxes[mid] > value)
						max = mid - 1;
					else
						return true;
				}
				return false;
			}
			public isFull() => (boolean) {
				return board[index] == WALL or hasBox();
			}
			public isEmpty() => (boolean) {
				return board[index] != WALL and !hasBox();
			}
			public hasPlayer() => (boolean) {
				return state[1][0] == index;
			}

			public moveUp() => (Coordinate) {
				return Coordinate:create(index - width);
			}
			public moveDown() => (Coordinate) {
				return Coordinate:create(index + width);
			}
			public moveLeft() => (Coordinate) {
				return Coordinate:create(index - 1);
			}
			public moveRight() => (Coordiante) {
				return Coordinate:create(index + 1);
			}
			public moveUpLeft() => (Coordinate) {
				return Coordinate:create(index - width - 1);
			}
			public moveUpRight() => (Coordinate) {
				return Coordinate:create(index - width + 1);
			}
			public moveDownLeft() => (Coordinate) {
				return Coordinate:create(index + width - 1);
			}
			public moveDownRight() => (Coordinate) {
				return Coordinate:create(index + width + 1);
			}

			public equals(Object other) => (boolean) {
				if (other is Coordinate)
					return index == cast<Coordinate>(other).index;
				return false;
			}
			public compare(Coordinate other) => (int) {
				return index - other.index;
			}
			public hashCode() => (int) {
				return index;
			}
			public toString() => (String) {
				MutableString sb = MutableString:create();
				for (int row = 0; row < height; row += 1) {
					for (int col = 0; col < width; col += 1) {
						Coordinate coord = Coordinate:create(row, col);
						if (equals(coord))
							sb.append('X');
						else if (coord.isWall())
							sb.append('#');
						else if (coord.hasPlayer())
							sb.append('@');
						else if (coord.isTarget() and coord.hasBox())
							sb.append('*');
						else if (coord.hasBox())
							sb.append('o');
						else if (coord.isTarget())
							sb.append('.');
						else
							sb.append(' ');
					}
					sb.append(System.getProperty("line.separator"));
				}
				return sb.toString();
			}

			public iterator() => (Iterator<Coordinate>) {
				return CoordinateIterator:create();
			}
			private class CoordinateIterator implements Iterator<Coordinate> {
				int state = 0;
				public immutable hasNext() => (boolean) {
					return state < 4;
				}
				public next() => (Coordinate) {
					switch (state) {
						case (0) {
							state += 1;
							return moveUp();
						} case (1) {
							state += 1;
							return moveDown();
						} case (2) {
							state += 1;
							return moveLeft();
						} case (3) {
							state += 1;
							return moveRight();
						} default {
							throw NoSuchElementException:create();
						}
					}
				}
			}
		}

		public immutable iterator() => (Iterator<Coordinate>) {
			return StateIterator:create();
		}
		private class StateIterator implements Iterator<Coordinate> {
			Coordinate current = Coordinate:create();
			public immutable hasNext() => (boolean) {
				return current != null;
			}
			public next() => (Coordinate) {
				if (current == null)
					throw NoSuchElementException:create();
				Coordinate temp = current;
				current = temp.next();
				return temp;
			}
		}
	}
}
