class shadow.utility@LinkedList<V> implements List<V>
{
	get int size = 0, modifications = 0;
	final Node header = Node:create();

	private final class Node
	{
		get Node prev = this, next = this;
		get nullable V value = null;
		private create() { }
		private create( V initialValue, Node after )
		{
			( after:prev:next, prev,       next,  after:prev ) =
			( this,            after:prev, after, this       );
			value = initialValue;
			size += 1;
			modifications += 1;
		}
		private set value( V initialValue ) => ()
		{
			value = initialValue;
			modifications += 1;
		}
		private clear() => ()
		{
			( prev, next ) = ( this, this );
			size = 0;
			modifications += 1;
		}
		private delete() => ()
		{
			( prev:next, next:prev ) = ( next, prev );
			size -= 1;
			modifications += 1;
		}
	}
	private findNode( int index ) => ( Node node )
	{
		if ( cast<uint>index >= cast<uint>size )
			throw IndexOutOfBoundsException:create();
		Node current = header;
		if ( index < size / 2 )
			while ( index != 0 )
			{
				current = current->next;
				index -= 1;
			}
		else
			while ( index != size )
			{
				current = current->prev;
				index += 1;
			}
		return current;
	}
	private findNode( V value ) => ( Node node )
	{
		( , nullable Node node ) = find(value);
		return node;
	}
	private find( int index ) => ( int index, nullable Node node )
	{
		return ( index, findNode(index) );
	}
	private find( V value ) => ( int index, nullable Node node )
	{
		int index = 0;
		Node current = header;
		while (true)
		{
			current = current->next;
			if ( current === header )
				return ( -1, null );
			if ( current->value == value )
				return ( index, current );
			index += 1;
		}
	}

	public index( int index ) => ( V value )
	{
		return findNode(index)->value;
	}
	public index( int index, V value ) => ()
	{
		if ( index == size )
			Node:create(value, header);
		else
			findNode(index)->value = value;
	}

	public add( V value ) => ( boolean added )
	{
		Node:create(value, header);
		return true;
	}
	public remove( V value ) => ( boolean removed )
	{
		try
		{
			check(findNode(value)).delete();
			return true;
		}
		recover
		{
			return false;
		}
	}
	public delete( int index ) => ( V value )
	{
		findNode(index).delete();
	}
	public indexOf( V value ) => ( int index )
	{
		return find(value);
	}
	public contains( V value ) => ( boolean found )
	{
		return find(value) != -1;
	}
	public clear() => ()
	{
		header.clear();
	}

	public immutable iterator() => ( Iterator<V> )
	{
		return LinkedListIterator:create();
	}
	private final class LinkedListIterator implements Iterator<V>
	{
		Node current = header->next;
		int expectedModifications = modifications;

		private immutable checkForModifications() => ()
		{
			if ( modifications != expectedModifications )
				throw IllegalModificationException:create();
		}
		public immutable hasNext() => ( boolean )
		{
			checkForModifications();
			return current !== header;
		}
		public next() => ( V value )
		{
			checkForModifications();
			if ( !hasNext() )
				throw IndexOutOfBoundsException:create();
			( V value, current ) = ( current->value, current->next );
			return value;
		}
	}
}
