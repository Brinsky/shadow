import shadow.io@Console;

immutable class shadow.standard@GenericClass extends Class
{	
	Object[] parameters; //double the size for class and methods
	//Class rawClass;

	protected create(int flags, int size, String name, Class parent, Class[] interfaces, immutable Object[] data, immutable Object[] parameters )
	{
		super(flags, size, name, parent, interfaces, data);
		//this:rawClass = rawClass;
		this:parameters = parameters;
	}

	public isSubtype( Class other ) => ( boolean )
	{
		if( other.isArray() or other.isMethod() )
			return false;
	
		if ( this === other )
			return true;
		
		try
		{
			if ( !other.isInterface() )
			{
				//if( !other.isGeneric() )
				return check(this->parent).isSubtype(other); //run up parental chain
				
				/*	
				//other is generic
				GenericClass genericOther = cast<GenericClass>(other);
				if( rawClass.isSubtype(genericOther:rawClass) and parameters->size >= genericOther:parameters->size )
				{
					for ( int i = 0; i < genericOther:parameters->size; i += 1 )
						if( !check(parameters[i]).equal(check(genericOther:parameters[i])) )
							return false;
							
					return true;
				}
				*/
				return false;				
			}
			else
			{
				Class[] interfaces = this->interfaces;
			 	for ( int i = 0; i < interfaces->size; i += 1 )
				{					 
					if( interfaces[i] === other )
						return true;			
				}
			}				
		}
		recover
		{}
		
		return false;
	}
	
	private findClass( GenericClass[] classes, Class[] parameters ) => (nullable Class)
	{
		try
		{
			for( int i = 0; i < classes->size; i += 1 )
			{
				boolean matching = true;
				for( int j = 0; j < parameters->size and matching; j += 1 )
					if( parameters[j] !== check(classes[i]):parameters[j * 2] )
						matching = false;
						
				if( matching )
					return cast<Class>(classes[i]);
			}
		}
		recover
		{}		
		
		return null;
	}
}
