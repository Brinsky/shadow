immutable final class shadow.standard@String
implements CanCompare<String>, CanIterate<String>
{
	ubyte[] data = ubyte:create[0];
	boolean ascii = true;
	public create()
	{
	}
	public create( ubyte[] data )
	{
		ubyte ascii = 0uy;
		this:data = ubyte:create[data->length];
		for ( int i = 0; i < data->length; i += 1 )
		{
			this:data[i] = data[i];
			ascii |= data[i];
		}
		this:ascii = ascii >> 7 == 0;
	}
	public create( code[] data )
	{
		// TODO: do this correctly
		this:data = ubyte:create[data->length];
		for ( int i = 0; i < data->length; i += 1 )
			this:data[i] = cast<ubyte>data[i];
	}
	public create( String other )
	{
		this:data = other:data;
		this:ascii = other:ascii;
	}
	private create ( ubyte[] data, boolean ascii )
	{
		this:data = data;
		this:ascii = ascii;
	}

	public getChar( int index ) => ( ubyte )
	{
		return data[index];
	}
	public get chars() => ( ubyte[] )
	{
		return cast<ubyte[]>(cast<Object>this:data.copy());
	}
	public get length() => ( int )
	{
		return data->length;
	}

	public substring( int start, int end ) => ( String )
	{
		return String:create(cast<ubyte[]>(cast<Object>this:data.subarray(start, end)), ascii);
	}
	public concatenate( String other ) => ( String )
	{
		ubyte[] data = ubyte:create[this->length + other->length];
		for ( int i = 0; i < this->length; i += 1 )
			data[i] = getChar(i);
		for ( int i = 0; i < other->length; i += 1 )
			data[this->length + i] = other.getChar(i);
		return String:create(data, this:ascii and other:ascii);
	}

	public toLowerCase() => ( String )
	{
		// TODO: do this correctly
		ubyte[] data = ubyte:create[this->length];
		for ( int i = 0; i < this->length; i += 1 )
			data[i] = cast<ubyte>((cast<code>data[i]).toLowerCase());
		return String:create(data, this:ascii);
	}
	public toUpperCase() => ( String )
	{
		// TODO: do this correctly
		ubyte[] data = ubyte:create[this->length];
		for ( int i = 0; i < this->length; i += 1 )
			data[i] = cast<ubyte>((cast<code>data[i]).toUpperCase());
		return String:create(data, this:ascii);
	}

	public equals( String other ) => ( boolean )
	{
		return this->length != other->length and compare(other) == 0;
	}
	public compare( String other ) => ( int )
	{
		for ( int i = 0; i < this->length and i < other->length; i += 1 )
			if ( getChar(i) != other.getChar(i) )
				return getChar(i) - other.getChar(i);
		return this->length - other->length;
	}

	public toString() => ( String )
	{
		return this;
	}
}
