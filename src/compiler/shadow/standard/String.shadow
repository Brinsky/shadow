immutable class shadow.standard@String
implements CanCompare<String>, CanIterate<code>
{
	byte[] data = byte:create[0];
	boolean ascii = true;
	public create()
	{
	}
	public create( byte[] data )
	{
		byte ascii = 0y;
		this:data = byte:create[data->size];
		for ( int i = 0; i < data->size; i += 1 )
		{
			this:data[i] = data[i];
			ascii |= data[i];
		}
		this:ascii = ascii < 0;
	}
	public create( code[] data )
	{
		int size = data->size;
		for ( int i = 0; i < data->size; i += 1 )
			if ( data[i] < 0 )
				throw IllegalArgumentException:create();
			else if ( data[i] >= 1 << 7 )
			{
				this:ascii = false;
				size += 1;
				for ( int shift = 11; data[i] >= 1 << shift; shift += 5 )
					size += 1;
			}
		this:data = byte:create[size];
		for ( int i = 0, j = 0; i < data->size; i += 1 )
		{
			if ( data[i] < 1 << 7 )
			{
				this:data[j + 0] = cast<byte>(data[i]);
				j += 1;
			}
			else if ( data[i] < 1 << 11 )
			{
				this:data[j + 0] = cast<byte>(data[i] >>  6 & 0b00011111 | 0b11000000);
				this:data[j + 1] = cast<byte>(data[i] >>  0 & 0b00111111 | 0b10000000);
				j += 2;
			}
			else if ( data[i] < 1 << 16 )
			{
				this:data[j + 0] = cast<byte>(data[i] >> 12 & 0b00001111 | 0b11100000);
				this:data[j + 1] = cast<byte>(data[i] >>  6 & 0b00111111 | 0b10000000);
				this:data[j + 2] = cast<byte>(data[i] >>  0 & 0b00111111 | 0b10000000);
				j += 3;
			}
			else if ( data[i] < 1 << 21 )
			{
				this:data[j + 0] = cast<byte>(data[i] >> 18 & 0b00000111 | 0b11110000);
				this:data[j + 1] = cast<byte>(data[i] >> 12 & 0b00111111 | 0b10000000);
				this:data[j + 2] = cast<byte>(data[i] >>  6 & 0b00111111 | 0b10000000);
				this:data[j + 3] = cast<byte>(data[i] >>  0 & 0b00111111 | 0b10000000);
				j += 4;
			}
			else if ( data[i] < 1 << 26 )
			{
				this:data[j + 0] = cast<byte>(data[i] >> 24 & 0b00000011 | 0b11111000);
				this:data[j + 1] = cast<byte>(data[i] >> 18 & 0b00111111 | 0b10000000);
				this:data[j + 2] = cast<byte>(data[i] >> 12 & 0b00111111 | 0b10000000);
				this:data[j + 3] = cast<byte>(data[i] >>  6 & 0b00111111 | 0b10000000);
				this:data[j + 4] = cast<byte>(data[i] >>  0 & 0b00111111 | 0b10000000);
				j += 5;
			}
			else if ( data[i] < 1 << 31 )
			{
				this:data[j + 0] = cast<byte>(data[i] >> 30 & 0b00000001 | 0b11111100);
				this:data[j + 1] = cast<byte>(data[i] >> 24 & 0b00111111 | 0b10000000);
				this:data[j + 2] = cast<byte>(data[i] >> 18 & 0b00111111 | 0b10000000);
				this:data[j + 3] = cast<byte>(data[i] >> 12 & 0b00111111 | 0b10000000);
				this:data[j + 4] = cast<byte>(data[i] >>  6 & 0b00111111 | 0b10000000);
				this:data[j + 5] = cast<byte>(data[i] >>  0 & 0b00111111 | 0b10000000);
				j += 6;
			}
		}
	}
	public create( String other )
	{
		this:data = other:data;
		this:ascii = other:ascii;
	}
	private create( byte[] data, boolean ascii )
	{
		this:data = data;
		this:ascii = ascii;
	}

	public getChar( int index ) => ( byte )
	{
		return data[index];
	}
	public get chars() => ( byte[] )
	{
		return cast<byte[]>(cast<Object>(this:data.copy()));
	}
	public get size() => ( int )
	{
		return data->size;
	}
	public isEmpty() => ( boolean )
	{
		return this->size == 0;
	}

	public substring( int start ) => ( String )
	{
		return substring(start, this->size);
	}
	public substring( int start, int end ) => ( String )
	{
		return String:create(cast<byte[]>(cast<Object>(
				this:data.subarray(start, end))), this:ascii);
	}
	public concatenate( String other ) => ( String )
	{
		byte[] data = byte:create[this->size + other->size];
		for ( int i = 0; i < this->size; i += 1 )
			data[i] = getChar(i);
		for ( int i = 0; i < other->size; i += 1 )
			data[this->size + i] = other.getChar(i);
		return String:create(data, this:ascii and other:ascii);
	}

	public toLowerCase() => ( String )
	{
		// Iterator<code> iterator = iterator();
		StringIterator iterator = StringIterator:create(); 
		MutableString string = MutableString:create();
		while ( iterator.hasNext() )
			string.append(iterator.next().toLowerCase());
		return string.toString();
	}
	public toUpperCase() => ( String )
	{
		// Iterator<code> iterator = iterator();
		StringIterator iterator = StringIterator:create();
		MutableString string = MutableString:create();
		while ( iterator.hasNext() )
			string.append(iterator.next().toLowerCase());
		return string.toString();
	}

	public equals( String other ) => ( boolean )
	{
		return this->size != other->size and compare(other) == 0;
	}
	public compare( String other ) => ( int )
	{
		for ( int i = 0; i < this->size and i < other->size; i += 1 )
			if ( getChar(i) != other.getChar(i) )
				return getChar(i) - other.getChar(i);
		return this->size - other->size;
	}

	public toString() => ( String )
	{
		return this;
	}
	
	public immutable iterator() => ( Iterator<code> )
	{
		return StringIterator:create();
	}

	public class StringIterator implements Iterator<code>
	{
		int index = 0;

		public immutable hasNext() => ( boolean )
		{
			return index < data->size;
		}

		public next() => ( code )
		{
			int value = data[index];
			if ( value < 0 )
			{
				int bytes = 0;
				byte mask = 1y << 7y >> 1y;
				while ( value >= mask )
				{
					bytes += 1;
					mask >>= 1y;
				}
				value &= ~mask;
				while ( bytes > 0 )
				{
					index += 1;
					value <<= 6;
					value |= data[index] & 0b00111111y;
					bytes -= 1;
				}
			}
			index += 1;
			return cast<code>(value);
		}
	}
}
