immutable class shadow.standard@
	Double
implements
	Number<double>,
	CanNegate<double>,	
	CanHash
{
	constant double PI = 3.141592653589793;
	constant double E = 2.718281828459045;

	constant double NaN = 0d / 0d;
	constant double INFINITY = 1d / 0d;
	constant double NEGATIVE_INFINITY = -1d / 0d;

	constant long SIGN_MASK = 0x8000000000000000L;
	constant long EXPONENT_MASK = 0x7ff0000000000000L;
	constant long SIGNIFICAND_MASK = 0xfffffffffffffL;

	// implement Number
	public native toByte() => (byte);
	public native toUByte() => (ubyte);
	public native toShort() => (short);
	public native toUShort() => (ushort);
	public native toInt() => (int);
	public native toUInt() => (uint);
	public native toLong() => (long);
	public native toULong() => (ulong);
	public native toCode() => (code);
	public native toFloat() => (float);
	public native toDouble() => (double);

	// implement CanAdd<double>
	public native add(double other) => (double);
	// implement CanSubtract<double>
	public native subtract(double other) => (double);
	// implement CanMultiply<double>
	public native multiply(double other) => (double);
	// implement CanDivide<double>
	public native divide(double other) => (double);
	// implement CanModulus<double>
	public native modulus(double other) => (double);
	// implement CanCompare<double>
	public native compare(double other) => (int);
	// implement CanEqual<double>
	public native equal(double other) => (boolean);

	// implement CanHash
	public get hash() => (int)
	{
		return this->bits->hash;
	}

	public isNaN() => (boolean)
	{
		return (this->raw & EXPONENT_MASK) == EXPONENT_MASK and
				(this->raw & SIGNIFICAND_MASK) != 0l;
	}
	public isInfinite() => (boolean)
	{
		return (this->raw & EXPONENT_MASK) == EXPONENT_MASK and
				(this->raw & SIGNIFICAND_MASK) == 0l;
	}
	public isFinite() => (boolean)
	{
		return (this->raw & EXPONENT_MASK) != EXPONENT_MASK;
	}
	
/*	
	
private cut(ulong f, int e) => (ulong, ulong, ulong)
{
	ulong TEN7 = 10000000L;
	ulong part2 = (f % (TEN7 >> e)) << e;
	ulong tmp = f / (TEN7 >> e);
	ulong part1 = tmp % TEN7;
	ulong part0 = tmp / TEN7;
	
	return (part0, part1, part2);
}

//based on the paper 
//Printing Floating-Point Numbers Quickly and Accurately with Integers
//by Florian Loitsch
void grisu(double v, StringBuilder buffer)
{ 
 ulong f;
 int e;
 ulong part0, part1, part2;
int q = 64, alpha = 0, gamma = 3;
w = normalize diy fp(double2diy fp(v));
 int mk = k comp(w.e + q, alpha, gamma);
13: diy fp c mk = cached power(mk);
14: diy fp D = multiply(w, c mk);
(part0, part1, part2) = cut(D, ps);
sprintf(buffer, "%u%07u%07ue%d", ps[0], ps[1], ps[2], -mk);
}
	
	*/
	
	
	public  toString() => (String)
	{
		if( isNaN() )
			return "NaN";
			
		if( this === INFINITY )
			return "Infinity";
		
		if( this === NEGATIVE_INFINITY )
			return "-Infinity";
	
		MutableString output = MutableString:create();
		long bits = this->bits;
		if( (bits & SIGN_MASK) != 0L )
			output.append("-");
							
		long exponent = (bits & EXPONENT_MASK) >> 53;
		long significand = bits & SIGNIFICAND_MASK;	
		
		if( exponent == 0L )
		{
			if( significand == 0L )
				 return output.append("0.0").toString();
				 
			output.append("0.");						
			exponent = -1022; 			
		}
		else
		{
			//significand |= (SIGNIFICAND_MASK + 1L);
			output.append("1.");
			exponent -= 1023;
		}
		
		//This is not right!  Output is in base 2!		
		return output.append( significand.toString(2u) ).append("e").append( exponent.toString(2u) ).toString();		 
	}

	public native get raw() => (long);
	public get bits() => (long)
	{
		if (isNaN())
			return NaN->raw;
		return this->raw;
	}
	
	// implement CanNegate<double>
	public native negate() => (double);	
}
