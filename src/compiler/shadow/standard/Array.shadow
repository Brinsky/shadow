import shadow.io@Console;

abstract class shadow.standard@Array<T> implements CanIndexStore<int[],T>, CanIterate<T>
{
	get immutable int[] lengths;
	Object data;
	private create( int[] lengths, Object data )	
	{
		this:lengths = lengths;		
		this:data = data;		
	}
	public create( int[] lengths )
	{
		this:lengths = cast<int[]>(cast<Object>(lengths.copy()));
		this:data = allocate(T:class, this->size); // T:class.allocate(this->size);
	}
	private immutable native allocate( Class type, int size ) => ( Object );

	public immutable get size() => ( int )
	{
		int size = lengths[0];
		for ( int i = 1; i < this->dims; i += 1 )
			size *= lengths[i];
		return size;
	}
	
	public immutable native get dims() => ( int );
	
	public immutable copy() => ( Array<T> )
	{
		Array<T> copy = Array<T>:create(this->lengths, allocate(T:class, this->size));
		int[] indices = int:create[this->dims];
		while ( indices[0] != this->lengths[0] )
		{
			copy.index(indices, index(indices));
			int i = indices->size - 1;
			for ( indices[i] += 1; i > 0 and indices[i] == this->lengths[i];
					i -= 1, indices[i] += 1 )
				indices[i] = 0;
		}
		return copy;
	}
	
	//only makes sense for 1D arrays?
	public immutable native subarray( int start, int end ) => ( Array<T> );

	public immutable native index( int[] indices ) => (T);
	public native index( int[] indices, T value ) => ();

	public immutable getBaseClass() => ( Class )
	{
		return T:class;
	}

	public immutable toString() => ( String )
	{
		if ( this->size == 0 )
			return "[]";
		MutableString string = MutableString:create("[ ");
		int[] indices = int:create[this->dims];
		boolean first = true;
		while ( indices[0] != this->lengths[0] )
		{
			if ( first )
				first = false;
			else
				string.append(", ");
			string.append(index(indices));
			int i = indices->size - 1;
			for ( indices[i] += 1; i > 0 and indices[i] == this->lengths[i];
					i -= 1, indices[i] += 1 )
				indices[i] = 0;
		}
		return string.append(" ]").toString();
	}
	
	public readonly iterator() => (Iterator<T>)
	{
		return ArrayIterator:create();
	} 
	
	private class ArrayIterator implements Iterator<T>
	{
		int[] position = int:create[lengths->size];
		
		public create()
		{
			Console out = Console:instance;
			out.printLine("Lengths: " # lengths );
			out.printLine("Position: " # position );
			out.printLine();
		}
		
		public immutable hasNext() => (boolean)
		{
			for( int i = 0; i < lengths->size; i += 1 )
				if( position[i] < lengths[i] - 1 )
					return true;
					
			return false;		
		}
		
		public next() => (T)
		{
			boolean carry = true;
			/*			
			for( int i = lengths->size - 1; i >= 0 and carry; i -= 1 )
			{
				if( position[i] < lengths[i] - 1 )
				{
					position[i] += 1;
					carry = false;
				}
				else
					position[i] = 0;
			}
			*/
			
			for( int i = 0; i < lengths->size and carry; i += 1 )
			{
				if( position[i] < lengths[i] - 1 )
				{
					position[i] += 1;
					carry = false;
				}
				else
					position[i] = 0;
			}
			
			if( carry )
				throw IndexOutOfBoundsException:create();
			else
				return index( position ); 
		}
	}
}
