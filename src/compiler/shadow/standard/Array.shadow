package shadow.standard;

// Is abstract final (not valid in java) like having only private constructors?
//		aka. can not be created outside of this class
/*native*/ abstract final class Array<T>
{
	private /*immutable*/ long data = 0;
	private /*immutable*/ int[] lengths = new int[0];
	private Class baseClass = Object.class;

	// TODO: Optimize these. For now they are just to reduce
	//		 the amount of native code that keeps changing.
	public final getLength() => ( int )
	{
		return getLength(0);
	}
	public final getLength( int dimension ) => ( int )
	{
		return getLengths()[ dimension ];
	}
	public final getDimensions() => ( int )
	{
		nullable int[][,] test; // = new int[1][2,3];
		try
		{
			return check(test).getLength(1);
		}
		recover
		{
			return 0;
		}
		
	}

	// end or length... that is the question
	// TODO: remove elementSize by fixing getBaseClass()
	public final native subarray( int offset, int length, int elementSize ) => ( Object/*Array<T>*/ );

	// TODO: This return value must eventually be immutable.
	//		 The returned array has direct access to the
	//		 internal lengths which must not be changed.
	public final getLengths() => ( /*immutable*/ int[] /*Array<int>*/ )
	{
		return lengths;
	}
	public final getBaseClass() => ( Class )
	{
		return baseClass;
	}

	// Maybe use these methods in an Indexable<T>/Indexed<T> interface?
	// Although it might only be used for random access collections
	//		(like java's java.util.RandomAccess).
	/* public final T get( int index ); */
	/* public final void set( int index, T value ); */
	
	// Maybe use this method in an Iterable<T>/Iterated<T> interface?
	//		(I feel like I stole this straight from java)
	// It seems like Index(able|ed)<T> implies Itera(ble|ted)<T>.
	//		(but not vice-versa) Interface hierarchy maybe?
	/* public final Iterator<T> createIterator(); */
}
