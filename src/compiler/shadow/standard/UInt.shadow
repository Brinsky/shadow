immutable class shadow.standard@
	UInt
implements
	Integer<uint>,
	Integer<ulong>,
	Number<float>,
	Number<double>,
	CanHash
{
	// implement Integer<uint>
	public native bitOr(uint other) => (uint);
	public native bitXor(uint other) => (uint);
	public native bitAnd(uint other) => (uint);

	// implement Number<uint>
	public native add(uint other) => (uint);
	public native subtract(uint other) => (uint);
	public native multiply(uint other) => (uint);
	public native divide(uint other) => (uint);
	public native modulus(uint other) => (uint);

	// implement CanCompare<uint>
	public native compare(uint other) => (int);

	// implement CanEqual<uint>
	public native equal(uint other) => (boolean);


	// implement Integer<ulong>
	public bitOr(ulong other) => (ulong)
	{
		return cast<ulong>(this) | other;
	}
	public bitXor(ulong other) => (ulong)
	{
		return cast<ulong>(this) ^ other;
	}
	public bitAnd(ulong other) => (ulong)
	{
		return cast<ulong>(this) & other;
	}

	// implement Number<ulong>
	public add(ulong other) => (ulong)
	{
		return cast<ulong>(this) + other;
	}
	public subtract(ulong other) => (ulong)
	{
		return cast<ulong>(this) - other;
	}
	public multiply(ulong other) => (ulong)
	{
		return cast<ulong>(this) * other;
	}
	public divide(ulong other) => (ulong)
	{
		return cast<ulong>(this) / other;
	}
	public modulus(ulong other) => (ulong)
	{
		return cast<ulong>(this) % other;
	}

	// implement CanCompare<ulong>
	public compare(ulong other) => (int)
	{
		return cast<ulong>(this).compare(other);
	}

	// implement CanEqual<ulong>
	public equal(ulong other) => (boolean)
	{
		return cast<ulong>(this) == other;
	}


	// implement Number<float>
	public add(float other) => (float)
	{
		return cast<float>(this) + other;
	}
	public subtract(float other) => (float)
	{
		return cast<float>(this) - other;
	}
	public multiply(float other) => (float)
	{
		return cast<float>(this) * other;
	}
	public divide(float other) => (float)
	{
		return cast<float>(this) / other;
	}
	public modulus(float other) => (float)
	{
		return cast<float>(this) % other;
	}

	// implement CanCompare<float>
	public compare(float other) => (int)
	{
		return cast<float>(this).compare(other);
	}

	// implement CanEqual<float>
	public equal(float other) => (boolean)
	{
		return cast<float>(this) == other;
	}


	// implement Number<double>
	public add(double other) => (double)
	{
		return cast<double>(this) + other;
	}
	public subtract(double other) => (double)
	{
		return cast<double>(this) - other;
	}
	public multiply(double other) => (double)
	{
		return cast<double>(this) * other;
	}
	public divide(double other) => (double)
	{
		return cast<double>(this) / other;
	}
	public modulus(double other) => (double)
	{
		return cast<double>(this) % other;
	}

	// implement CanCompare<double>
	public compare(double other) => (int)
	{
		return cast<double>(this).compare(other);
	}

	// implement CanEqual<double>
	public equal(double other) => (boolean)
	{
		return cast<double>(this) == other;
	}


	// implement CanHash
	public get hash() => (int)
	{
		return cast<int>(this);
	}


	public min(uint other) => (uint)
	{
		return this < other ? this, other;
	}
	public max(uint other) => (uint)
	{
		return this > other ? this, other;
	}


	public toString() => (String)
	{
		return toString(10u);
	}
	public toString(uint base) => (String)
	{
		MutableString string = MutableString:create();
		uint value = this;
		do
		{
			string.append(digit(value % base));
			value /= base;
		}
		while (value != 0u);
		return string.reverse().toString();
	}
	private digit(uint digit) => (code)
	{
		if (digit < 10u)
			return cast<code>(digit + '0');
		return cast<code>(digit - 10u + 'a');
	}
}
