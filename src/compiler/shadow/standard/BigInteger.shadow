immutable class BigInteger
implements Number<BigInteger>
{
	uint[] data;
	boolean negative;
	
	constant ulong BASE = 4294967296uL;
	
	public equal(BigInteger other) => (boolean)
	{
		return compare(other) == 0;
	}
	
	public compare(BigInteger other) => (int)
	{
		if( negative )
		{
			if( other:negative )
				return -unsignedCompare( data, other:data );
			else
				return -1;		
		}
		else
		{
			if( other:negative )
				return 1;
			else
				return unsignedCompare( data, other:data );
		}	
	}
	
	public add(BigInteger other) => (BigInteger)
	{
		if( negative == other:negative )
			return BigInteger:create( unsignedAdd(data, other:data), negative );
			
		//opposite signs
		int comparison = unsignedCompare(data, other:data);
		if( comparison > 0 )
			return BigInteger:create( unsignedSubtract(data, other:data), negative );
		else if( comparison < 0 )
			return BigInteger:create( unsignedSubtract(other:data, data), other:negative);
		else
			return BigInteger:create( 0 );		
	}
	
	public subtract(BigInteger other) => (BigInteger)
	{
		if( negative != other:negative )
			return BigInteger:create( unsignedAdd(data, other:data), negative );
			
		//same signs
		int comparison = unsignedCompare(data, other:data);
		if( comparison > 0 )
			return BigInteger:create( unsignedSubtract(data, other:data), negative );
		else if( comparison < 0 )
			return BigInteger:create( unsignedSubtract(other:data, data), !other:negative);
		else
			return BigInteger:create( 0 );		
	}
	
	public multiply(BigInteger other) => (BigInteger)
	{	
		return BigInteger:create( unsignedMultiply( data, other:data), negative xor other:negative );	
	}
	
	private unsignedMultiply(uint[] first, uint[] second) => (uint[])
	{
		uint[] result = uint:create[first->size + second->size];
		for( int i = 0; i < first->size; i += 1 )
		{		
			if( first[i] > 0u )
			{
				ulong carry = 0uL;
				ulong product = 0uL;
			
				for( int j = 0; j < second->size; j += 1 )
				{
					product = cast<ulong>(first[i])*second[j] + result[i + j] + carry ;
					carry = product / BASE;
					result[i + j] = cast<uint>(product % BASE);
				}
				
				//never happens the last time
				if( carry > 0L )
					result[i + second->size] = cast<uint>(carry);
			}															
		}
		
		return removeZeroes(result);
	}
	
	public divide(BigInteger other) => (BigInteger)
	{
		int comparison = unsignedCompare(data, other:data);
		if( comparison < 0 )
			return BigInteger:create( 0 );
		
		if( comparison == 0 )
			return BigInteger:create( (negative xor other:negative ? -1 , 1) );
					
		return BigInteger:create( unsignedDivide( data, other:data ), negative xor other:negative );
	}
	
	public modulus(BigInteger other) => (BigInteger)
	{
		int comparison = unsignedCompare(data, other:data);
		if( comparison < 0 )
			return this;
		
		if( comparison == 0 )
			return BigInteger:create( 0 );
			
		uint[] quotient = unsignedDivide( data, other:data );
		uint[] product = unsignedMultiply( quotient, other:data ); 		
		uint[] remainder = unsignedSubtract( data, product );
		 
		if( remainder->size == 1 and remainder[0] == 0u )
			return BigInteger:create( 0 );
		
		return BigInteger:create( remainder, negative );
	}
	
	//unsignedDivide assumes that first is no smaller than second
	private unsignedDivide(uint[] first, uint[] second) => (uint[] quotient)
	{
		uint[] quotient = uint:create[first->size - second->size + 1];
		uint[] product;
		int comparison;
		for( int i = quotient->size - 1; i >= 0; i -= 1 )
		{
			uint max = cast<uint>(BASE - 1uL);
			uint min = 0u;
			uint mid = (max + min)/2u;
			
			while( min < max )
			{
				quotient[i] = mid;	
				product = unsignedMultiply( quotient, second );
				comparison = unsignedCompare( product, first );
				if( comparison == 0 )			
					return quotient;
				else if( comparison > 0 )
					max = mid - 1u;
				else
					min = mid + 1u;
					
				mid = (max + min)/2u;
			}
			
			quotient[i] = mid;	 
		}
		return quotient;
	}
	
	
	public create(int value)
	{
		data = uint:create[1];
		data[0] = value.abs();
		negative = value < 0;			
	}
	
	public create(long value)
	{
		ulong magnitude = value.abs();
		if( magnitude >= BASE )
		{
			data = uint:create[2];
			data[1] = cast<uint>(magnitude / BASE); 
			data[0] = cast<uint>(magnitude % BASE);					
		}
		else
		{
			data = uint:create[1];			 
			data[0] = cast<uint>(magnitude);		
		}
		negative = value < 0L;		
	}
	
	private unsignedCompare(uint[] data, uint[] other) => (int)
	{
		if( data->size < other->size )
			return -1;
		
		if( data->size > other->size )
			return 1;
			
		for( int i = data->size - 1; i >= 0; i -= 1 )
		{
			if( data[i] < other[i] )
				return -1;
			else if( data[i] > other[i] )
				return 1;
		}
		
		return 0;
	}
	
	private unsignedAdd(uint[] first, uint[] second) => (uint[])
	{
		uint[] result = uint:create[first->size.max(second->size) + 1];
		ulong carry = 0uL;
		ulong sum = 0uL;
		for( int i = 0; i < result->size; i += 1 )
		{
			sum = carry;
			if( i < first->size )
				sum += first[i];
			if( i < second->size )
				sum += second[i];
			carry = sum / BASE;
			result[i] = cast<uint>(sum % BASE);								
		}
		
		return removeZeroes( result );
	}
	
	//unsigned subtract assumes that second is never larger than first
	private unsignedSubtract(uint[] first, uint[] second) => (uint[] )
	{
		uint[] result = uint:create[first->size];
		ulong borrow = 0uL;
		ulong subtract = 0uL;
		for( int i = 0; i < result->size; i += 1 )
		{
			subtract = borrow;			
			if( i < second->size )
				subtract += second[i];
			if( subtract <= first[i] )
			{
				result[i] = cast<uint>(first[i] - subtract);
				borrow = 0uL;
			}
			else
			{
				result[i] = cast<uint>(BASE + first[i] - subtract);
				borrow = 1uL;
			}				
		}
		
		return removeZeroes( result );
	}
	
	
	private create( uint[] data, boolean negative )
	{
		this:data = data;
		this:negative = negative;	
	}
	
	
	private removeZeroes( uint[] values ) => ( uint[] )
	{
		int zeroes = 0;
		while( values[values->size - zeroes - 1] != 0 )
			zeroes += 1;
			
		if( zeroes == values->size )
			zeroes -= 1;
			
		if( zeroes > 0 )
			return cast<uint[]>( cast<Object>(values.subarray( 0, values->size - zeroes )));
		
		return values;
	}
	
	public toString() => (String)
	{
		return toString(10);	
	}
	
	public toString(int base) => (String)
	{
		if( base < 2 or base > 36 )
			throw IllegalArgumentException:create();
		
		if( isZero(data) )
			return "0";
			
		MutableString buffer = MutableString:create();
		BigInteger divisor = BigInteger:create(base);
		
		uint[] number = data;
		uint[] quotient;
		uint[] product;
		uint[] remainder;
		
		if( negative )
			buffer.append("-");
				
		do
		{
			quotient = unsignedDivide( number, divisor:data );
			product = unsignedMultiply( quotient, divisor:data ); 		
			remainder = unsignedSubtract( number, product );
			uint digit = remainder[0]; 
			
			if( digit >= 10 ) //A through Z
				buffer.append(cast<byte>(digit - 10 + 'A'));
			else
				buffer.append(cast<byte>(digit + '0'));
				
			number = quotient;				
		} while( !isZero( number ) );
		
		
		return buffer.reverse().toString();
	}
	
	public isZero(uint[] data) => (boolean)
	{
		return data->size == 1 and data[0] == 0u;
	}
	
	
	immutable public toByte() => (byte)
	{
		return cast<byte>(toInt());
	}
	
	public toUByte() => (ubyte)
	{
		return cast<ubyte>(data[0]);
	}
	
	public toShort() => (short)
	{
		return cast<short>(toInt());
	}
	
	public toUShort() => (ushort)
	{
		return cast<ushort>(data[0]);
	}
	
	public toInt() => (int)
	{
		return (negative ? -1 , 1 ) * cast<int>(data[0]);
	}
	
	public toUInt() => (uint)
	{
		return data[0];
	}
	
	public toLong() => (long)
	{
		return (negative ? -1L , 1L ) * cast<long>(toULong());
	}
	
	public toULong() => (ulong)
	{
		ulong value = data[0];
		if( data->size > 1 )
			value += data[1] * BASE;
		return value;	
	}
	
	public toCode() => (code)
	{
		return cast<code>(data[0]);	
	}	
	
	public toFloat() => (float)
	{
		return cast<float>( toDouble() );
	}
		
	public toDouble() => (double)
	{
		double total = 0.0;
		
		for( int i = data->size - 1; i >= 0; i -= 1 )
		{
			total *= BASE;
			total += data[i];		
		}
		
		return negative ? -total , total; 
	}
}