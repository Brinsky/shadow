immutable class shadow.standard@MethodClass extends AbstractClass
{	
	AbstractClass[] parameters = AbstractClass:create[0];
	AbstractClass[] returns = AbstractClass:create[0];	

	protected create(int flags, int size, AbstractClass[] parameters, AbstractClass[] returns)
	{ 
		super( flags, size );
		this:parameters = parameters;
		this:returns = returns;
	}	
	
	public isSubtype( AbstractClass other ) => ( boolean )
	{
		if( other.isMethod() )
		{ 
			try
			{
				MethodClass methodClass = cast<MethodClass>(other);
				if( methodClass:parameters->size == parameters->size and methodClass:returns->size == returns->size )
				{
					for( int i = 0; i < parameters->size; i += 1 )
						if( !check(methodClass:parameters[i]).isSubtype( check(parameters[i]) ) )
							return false;
	
					for( int i = 0; i < returns->size; i += 1 )
						if( !check(returns[i]).isSubtype( check(methodClass:returns[i]) ) )
							return false;
							
					return true;
				}
			}
			recover
			{}
			
			return false;
		}
		
		return false;
	}	
	
	public toString() => ( String )
	{
		MutableString out = MutableString:create("(");				
		for( int i = 0; i < parameters->size; i += 1 )
		{		
			if( i > 0 )
				out.append(", ");
			
			out.append(#parameters[i]);
		}
		
		out.append(") => (");
		
		for( int i = 0; i < returns->size; i += 1 )
		{		
			if( i > 0 )
				out.append(", ");
			
			out.append(#returns[i]);
		}
		
		out.append(")");
		return #out;	
	}
}
