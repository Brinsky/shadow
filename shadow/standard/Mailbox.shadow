import shadow:natives;

/**
 * Class {@code Mailbox} is the main component of the Message Passing
 * between Threads in the Shadow language. 
 *
 * @seeDoc shadow:standard@Thread
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Mailbox
{
	// this shouldn't be for too long; best time for it?
	readonly TimeSpan TIMEOUT = Time.fromMilliSeconds(5000);
	
	//private extern $interrupt(Thread instance, boolean shouldThrow) => (boolean);
	
	/*
	* NOTES
	*
	* Note1: We would like to notify all the waiting threads 
	*        that something happened whenever we enqueue or dequeue. 
	*        If the change that happened is not beneficial to those waiting
	*        threads, they will go right back to sleep until another change 
	*        happens or until they timeout. This avoids us busy waiting.
	*/
	
	Signaler signaler;
	MessageQueue list;
	Mutex mutex;
	//Thread owner;
	
	/**
	* Initializes a {@code Mailbox} with a backing array that has {@code min} items space to start with
	* and can expand up to {@code max}.
	*/
	public create(/*Thread owner,*/ int min, int max)
	{
//		this:owner = owner;
		this:list = MessageQueue:create(min, max);
		this:signaler = Signaler:create();
		this:mutex = Mutex:create();
	}	
	
	/**
	* Initializes a {@code Mailbox} with a backing array with an initial and maximum capacity of {@code size}.
	*/
	public create(/*Thread owner,*/ int size)
	{
		this(/*owner,*/ size, size);
	}
	
	/**
	* @throws FullMailboxException
	* @throws InterruptedException
	*/
	public sendTo(Object data, boolean blocking) => ()
	{
		CurrentThread.throwIfInterrupting();
		
		var message = Message:create(data);
		if(!blocking) {
			if(!list.enqueue(message)) {
				throw FullMailboxException:create("Mailbox is full");
			}
		} else {
			var stop = false;
			while(!stop) {
				stop = list.enqueue(message);
				
				if(!stop) {
					signaler.waitForNotify(TIMEOUT);
				}
			}
		}
		
		signaler.notifyAll();
	}
	
	/**
	* @throws EmptyMailboxException
	* @throws InterruptedException
	*/
	public receiveFirst(Class expectedType, boolean blocking) => (Object, Thread)
	{
		throw UnsupportedOperationException:create();
		/*CurrentThread.throwIfInterrupting();

		if(list.isEmpty()) {
			// if we don't immediately find the result and we are not blocking, then throw.
			if(!blocking) {
				throw EmptyMailboxException:create("Mailbox did not receive any messages, and is empty.");
			}

			// we block as long as the last is empty.
			while(list.isEmpty()) {
				signaler.waitForNotify(TIMEOUT);
			}
		}
		
		// dequeue should never throw because of an empty list,
		// but it can and will throw if the expectedType is not
		// the same as the available type.
		var message = list.dequeue(expectedType);
		
		signaler.notifyAll();
		
		return (message->data, message->sender);*/
	}
	
	/**
	* @throws EmptyMailboxException
	* @throws InterruptedException
	*/
	public receiveFirstFrom(Class expectedType, Thread sender, boolean blocking) => (Object)
	{
		CurrentThread.throwIfInterrupting();

		nullable var message = list.dequeue(sender, expectedType);
		if(!blocking) {
			if(message === null) {
				throw EmptyMailboxException:create("Mailbox is empty");
			}
		} else {
			while(message === null) {
				message = list.dequeue(sender, expectedType);
				
				if(message === null) {
					signaler.waitForNotify(TIMEOUT);
				}
			}
		}
		
		signaler.notifyAll();

		return (check(message)->data);
	}
	
	public sendTo(Object data) => ()
	{
		sendTo(data, true);
	}
	
	public receiveFirst(Class expectedType) => (Object, Thread)
	{
		return receiveFirst(expectedType, true);
	}
	
	public receiveFirstFrom(Class expectedType, Thread sender) => (Object)
	{
		return receiveFirstFrom(expectedType, sender, true);
	}
}