import shadow:natives;

/**
 * Class {@code Mailbox} is the main component of the Message Passing
 * between Threads in the Shadow language. 
 *
 * @seeDoc shadow:standard@Thread
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Mailbox
{
	// this shouldn't be for too long; best time for it?
	readonly TimeSpan TIMEOUT = Time.fromSeconds(30);
	
	/*
	* NOTES
	*
	* Note1: We would like to notify all the waiting threads 
	*        that something happened whenever we enqueue or dequeue. 
	*        If the change that happened is not beneficial to those waiting
	*        threads, they will go right back to sleep until another change 
	*        happens or until they timeout. This avoids us busy waiting.
	*/
	
	Signaler signaler;
	MessageQueue list;
	Mutex mutex;
	
	/**
	* Initializes a {@code Mailbox} with a backing array that has {@code min} items space to start with
	* and can expand up to {@code max}.
	*/
	public create(int min, int max)
	{
		this:list = MessageQueue:create(min, max);
		this:signaler = Signaler:create();
		this:mutex = Mutex:create();		
	}
	
	/**
	* Initializes a {@code Mailbox} with a backing array with an initial and maximum capacity of {@code size}.
	*/
	public create(int size)
	{
		this(size, size);
	}
	
	/**
	* @throws FullMailboxException
	* @throws InterruptedException
	*/
	public enqueue(Object data, boolean blocking) => ()
	{
		CurrentThread.throwIfInterrupting();
		
		mutex.lock();
		try {
			if(list.isFull()) {
				// if we don't immediately find the result and we are not blocking, then throw.
				if(!blocking) {
					throw FullMailboxException:create("Mailbox is full.");
				}
				
				do {
					waitForNotify();
				} while(list.isFull());
			}
			
			// enqueue should never throw since we should only
			// arrive here if the list is not full.
			list.enqueue(Message:create(data));
			
			// We notify all sleeping threads here. Check Note1.
			signaler.notifyAll();
			CurrentThread.sleep(1);
		} finally {
			mutex.unlock();
		}
	}
	
	/**
	* @throws EmptyMailboxException
	* @throws InterruptedException
	*/
	public dequeue(Class expectedType, boolean blocking) => (Object, Thread)
	{
		CurrentThread.throwIfInterrupting();

		mutex.lock();
		try {
			if(list.isEmpty()) {
				// if we don't immediately find the result and we are not blocking, then throw.
				if(!blocking) {
					throw EmptyMailboxException:create("Mailbox did not receive any messages, and is empty.");
				}

				// we block as long as the last is empty.
				do {
					waitForNotify();
				} while(list.isEmpty());
			}
			
			// dequeue should never throw because of an empty list,
			// but it can and will throw if the expectedType is not
			// the same as the available type.
			var message = list.dequeue(expectedType);

			// We notify all sleeping threads here. Check Note1.
			signaler.notifyAll();
			CurrentThread.sleep(1);
			
			return (message->data, message->sender);	
		} finally {
			mutex.unlock();
		}
	}
	
	/**
	* @throws EmptyMailboxException
	* @throws InterruptedException
	*/
	public dequeue(Class expectedType, Thread sender, boolean blocking) => (Object)
	{
		CurrentThread.throwIfInterrupting();
	
		mutex.lock();
		try {
			int index = list.indexOf(sender);

			if(index == -1) {
				// if we don't immediately find the result and we are not blocking, then throw.
				if(!blocking) {
					throw EmptyMailboxException:create("Mailbox did not receive any messages from that thread.");
				}
				
				// we block as long as we do not find a thread which matches the sender
				do {
					waitForNotify();
					index = list.indexOf(sender);
				} while(index == -1);
			}
			
			var message = list.removeAt(index, expectedType);
			
			// We notify all sleeping threads here. Check Note1.
			signaler.notifyAll();
			CurrentThread.sleep(1);

			return (message->data);
		} finally {
			mutex.unlock();
		}
	}
	
	public enqueue(Object data) => ()
	{
		enqueue(data, true);
	}
	
	public dequeue(Class expectedType) => (Object, Thread)
	{
		return dequeue(expectedType, true);
	}
	
	public dequeue(Class expectedType, Thread sender) => (Object)
	{
		return dequeue(expectedType, sender, true);
	}
	
	private waitForNotify() => ()
	{
		mutex.unlock();
		signaler.waitForNotify(TIMEOUT);
		mutex.lock();
	}
}