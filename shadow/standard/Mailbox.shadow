import shadow:natives;

/**
 * Class {@code Mailbox} is the main component of the Message Passing
 * between Threads in the Shadow language. 
 *
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Mailbox
{
	readonly TimeSpan TIMEOUT = Time.fromMinutes(1);
	
	/*
	* NOTES
	*
	* Note1: We would like to notify all the waiting threads 
	*        that something happened whenever we enqueue or dequeue. 
	*        If the change that happened is not beneficial to those waiting
	*        threads, they will go right back to sleep until another change 
	*        happens or until they timeout. This avoids us busy waiting.
	*/
	
	get Signaler signaler;

	HybridQueueArray list;
	Mutex mutex;
	
	public create(int count)
	{
		this:list = HybridQueueArray:create(count);
		this:signaler = Signaler:create();
		this:mutex = Mutex:create();
	}
	
	public enqueue(Object data, boolean blocking) => ()
	{		
		mutex.lock();
		try {
			if(list.isFull()) {
				// if we don't immediately find the result and we are not blocking, then throw.
				if(!blocking) {
					throw Exception:create("Mailbox is full.");
				}
				
				do {
					waitForNotify();
				} while(list.isFull());
			}
			
			// enqueue should never throw since we should only
			// arrive here if the list is not full.
			list.enqueue(Message:create(data));
			
			// We notify all sleeping threads here. Check Note1.
			signaler.notifyAll();
		} finally {
			mutex.unlock();
		}
	}
	
	public dequeue(Class expectedType, boolean blocking) => (Object, Thread)
	{
		mutex.lock();
		try {
			if(list.isEmpty()) {
				// if we don't immediately find the result and we are not blocking, then throw.
				if(!blocking) {
					throw NoDataException:create("Mailbox did not receive any messages, and is empty.");
				}

				// we block as long as the last is empty.
				do {
					waitForNotify();
				} while(list.isEmpty());
			}

			// dequeue should never throw because of an empty list,
			// but it can and will throw if the expectedType is not
			// the same as the available type.
			var message = list.dequeue(expectedType);

			// We notify all sleeping threads here. Check Note1.
			signaler.notifyAll();
			
			return (message->data, message->sender);	
		} finally {
			mutex.unlock();
		}
	}
	
	public dequeue(Class expectedType, Thread sender, boolean blocking) => (Object)
	{
		mutex.lock();
		try {
			int index = list.indexOf(sender);

			if(index == -1) {
				// if we don't immediately find the result and we are not blocking, then throw.
				if(!blocking) {
					throw NoDataException:create("Mailbox did not receive any messages from that thread.");
				}
				
				// we block as long as we do not find a thread which matches the sender
				do {
					waitForNotify();
					index = list.indexOf(sender);
				} while(index == -1);
			}
			
			var message = list.removeAt(index, expectedType);
			
			// We notify all sleeping threads here. Check Note1.
			signaler.notifyAll();
			return (message->data);
		} finally {
			mutex.unlock();
		}
	}
	
	public enqueue(Object data) => ()
	{
		enqueue(data, true);
	}
	
	public dequeue(Class expectedType) => (Object, Thread)
	{
		return dequeue(expectedType, true);
	}
	
	public dequeue(Class expectedType, Thread sender) => (Object)
	{
		return dequeue(expectedType, sender, true);
	}
	
	private waitForNotify() => ()
	{
		mutex.unlock();
		signaler.waitForNotify(TIMEOUT);
		mutex.lock();
	}
	
	private class Message
	{
		get Thread sender;
		get Object data;
		
		public create(Object data)
		{
			this:sender = CurrentThread->instance;
			this:data = copy(data);
		}
	}
	
	private class HybridQueueArray
		is CanIndex<int, Message> 
		and CanIndexStoreNullable<int, Message>
	{
		nullable Message[] elements;
		int start;
		get int size;
		
		public create(int capacity)
		{
			this:elements = Message:null[capacity];
			this:start = 0;
			this:size = 0;
		}
		
		public readonly get isFull() => (boolean)
		{
			return (size == elements->size);
		}
		
		public readonly get isEmpty() => (boolean)
		{
			return (size == 0);
		}
		
		public indexOf(Thread thread) => (int index)
		{
			for(int i = 0; i < size; i += 1) {
				if(thread === this[i]->sender) {
					return i;
				}
			}

			return -1;
		}

		public enqueue(Message message) => ()
		{
			if(isFull())
				throw FullListException:create();

			this[size] = message;
			size += 1;
		}
		
		public dequeue(Class expectedType) => (Message)
		{
			return removeAt(0, expectedType);
		}
		
		public removeAt(int index, Class expectedType) => (Message)
		{
			// retrieve the data and make sure that it is the same as the expectedType.
			// the indexer also checks for out of bounds exception, so we do not need
			// to worry about that.
			Message message = this[index];
			var dataType = message->data.getClass();
			if(dataType !== expectedType) {
				throw WrongTypeException:create(expectedType, dataType);
			}
			
			if(index == 0) {
				this[index] = null;
				start = (start + 1) % elements->size;
			} else {
				// we shift the array by one to the left.
				// assuming we are deleting the second item:
				// [1, 2, 3, 4, 5] -> [1, 3, 4, 5, null]
				for(int i = index; i < size - 1; i += 1) {
					this[i] = this[i + 1];
				}
				
				// set the last item to null since it is not used anymore
				this[size - 1] = null;
			}
			
			// decrease the size, since we deleted the item.
			size -= 1;
			
			// if the list is empty, we can start at zero again.
			if(isEmpty()) {
				start = 0;
			}
			
			return message;
		}
		
		// CanIndex<int, Message>
		public readonly index(int index) => (Message)
		{
			return check(elements[rawIndex(index)]);
		}
		
		// CanIndexStoreNullable<int, Message>
		public index(int index, nullable Message message) => ()
		{
			elements[rawIndex(index)] = message;
		}
		
		private readonly rawIndex(int index) => (int)
		{
			if(index < 0 or index >= elements->size)
				throw IndexOutOfBoundsException:create();
		
			return ((start + index) % elements->size);
		}
	}
}