/**
 * Singleton {@code CurrentThread} provides methods which can be called on the current thread.
 * It also provides a way to access the actual {@code Thread} instance of this thread. 
 * 
 * @author Claude Abounegm
 * @seeDoc shadow:standard@Thread
 */
immutable singleton shadow:standard@
	CurrentThread
is CanIndex<int, Thread>
{
	private readonly native sleep(Thread thread, int milliseconds) => ();
	private readonly native sleep(Thread thread, TimeSpan time) => ();
	
	/**
	* Gets the current thread's actual instance.
	*
	* @return The instance of the current thread.
	*/
	public native readonly get instance() => (Thread);
	
	/**
	* Gets the Shadow-specific thread ID.
	*/
	public readonly get id() => (int)
	{
		return instance()->id;
	}
	
	/**
	* Gets the main thread, which is the root of all threads.
	*/
	public readonly get main() => (Thread)
	{
		return instance()->main;
	}
	
	/**
	* Gets the {@code Thread} which spawned this thread. The Main thread does not
	* have a parent, and is null.
	*/
	public readonly get parent() => (nullable Thread)
	{
		return instance()->parent;
	}

	/**
	* Gets the name of the thread set at spawn time. If no name is set
	* at spawn time, the name takes the format "Thread#{id}".
	*/
	public readonly get name() => (String)
	{
		return instance()->name;
	}
	
	public interrupt() => ()
	{
		instance().interrupt();
	}
	
	public get shouldInterrupt() => (boolean)
	{
		return instance()->shouldInterrupt;
	}
	
	/**
	* Suspends the current running thread for the specfied amount of time.
	* 
	* @param timeout The amount of time to pause this thread for.
	*/
	public readonly sleep(TimeSpan timeout) => ()
	{
		sleep(instance(), timeout);
	}
	
	/**
	* Suspends the current running thread for {@code milliseconds} milliseconds.
	* 
	* @param millisecondsTimeout The milliseconds to pause this thread for.
	*/
	public readonly sleep(int millisecondsTimeout) => ()
	{
		sleep(instance(), millisecondsTimeout);
	}
	
	/**
	* Gets the n-th child that this thread spawned. This is NOT the Shadow-specific {@code Thread->id}.
	* If the thread has four children, this method could be used to retrieve the n-th child, for example
	* the third child (thus, its index is 2).
	* @param index the index of the child in the range [0, childrenCount).
	*/
	public readonly childAt(int index) => (Thread)
	{
		return instance().childAt(index);
	}
	
	/**
	* Gets the children of this thread, and if {@code recurse} is true, this method
	* will also traverse the children of the children recursively, until all children
	* have been visited.
	* Care should be taken using this function, as enumerating can throw an exception
	* if the children have changed.
	*
	* @return {@code CanIterate<Thread>} An iterable class to be used with a foreach loop.
	*/
	public readonly children(boolean recurse) => (CanIterate<Thread>)
	{
		return instance().children(recurse);
	}
	
	/**
	* Gets the children of this thread. This method only enumerates through the first generation
	* children of this thread. i.e. only the thread that this thread spawned.
	*
	* @return {@code CanIterate<Thread>} An iterable class to be used with a foreach loop.
	*/
	public readonly children() => (CanIterate<Thread>)
	{
		return instance().children();
	}
	
	/**
	* Sends the desired data to this thread. This method copies all the data before
	* sending it to the Thread. Thus no data is shared between two threads.
	* This is a blocking method, and it will block if the mailbox of this thread is full.
	* The method will immediately unblock when there is space for the item to be
	* deposited in the mailbox.
	*
	* @param data The data to be cloned and sent to this thread.
	* 
	* @throws InterruptedException If this thread was interrupted while waiting on a full mailbox.
	* @throws InvalidOperationException if this thread is dead or is the same as the receiving one.
	*
	* @seeDoc shadow:standard@Mailbox
	*/
	public readonly sendTo(Object data, Thread to) => ()
	{
		to.sendTo(data);
	}
	
	/**
	* Receives data with the desired {@code expectedType}. This method will throw an exception 
	* and will not retrieve the message if the expected type is not the same as the actual one
	* sent by the thread. A thread can send as many messages as it desires, but the receiving thread
	* should always receive the data in the order it was sent, or otherwise an exception is thrown.
	*
	* @throws WrongTypeException If the item attempted to retrieve does not have the same type as expectedType.
	* @throws InterruptedException If this thread was interrupted while waiting on an empty mailbox.
	* @throws IllegalArgumentException If this thread is the same as the from thread.
	* 
	* @seeDoc shadow:standard@Mailbox
	*/
	public readonly receiveFirst(Class expectedType) => (Object, Thread)
	{
		return instance().receiveFirst(expectedType);
	}
	
	/**
	* Receives data with the desired {@code expectedType} from the desired thread.
	* This method will throw an exception and will not retrieve the message if the
	* expected type is not the same as the actual one sent by the thread. A thread
	* can send as many messages as it desires, but the receiving thread should always
	* receive the data in the order it was sent, or otherwise an exception is thrown.
	*
	* @throws WrongTypeException If the item attempted to retrieve does not have the same type as expectedType.
	* @throws InterruptedException If this thread was interrupted while waiting on an empty mailbox.
	* @throws IllegalArgumentException If this thread is the same as the from thread.
	* 
	* @seeDoc shadow:standard@Mailbox
	*/
	public readonly receiveFirstFrom(Class expectedType, Thread from) => (Object)
	{
		return instance().receiveFirstFrom(expectedType, from);
	}
	
	/**
	* Checks whether the {@code thread} is the same as the current thread.
	* This is equivalent to {@code thread->isCurrentThread}, but with null checking as well.
	*
	* @param thread 
	*
	* @return {@code true} if the current thread is the same as the passed thread; otherwise, {@code false}.
	*/
	public readonly isEqualTo(nullable Thread thread) => (boolean)
	{
		return (thread !== null and check(thread) === instance());
	}
	
	/**
	* Gets the number of children the thread currently has. This method should be used with caution
	* even though it is thread safe. Since a thread can spawn threads at any time, this count can
	* drastically change between each call.
	*/
	public readonly get childrenCount() => (int)
	{
		return instance()->childrenCount;
	}
	
	// CanIndex<int, Thread>
	public readonly index(int index) => (Thread)
	{
		return instance()[index];
	}
	
	/**
	* Returns a string with the format: "Thread ({Thread->name}): {Thread->stateStr}".
	*/
	public readonly toString() => (String)
	{
		return #instance();
	}
}