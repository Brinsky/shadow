import shadow:io@Console;
import shadow:utility;
import shadow:natives;

/**
 * 
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Thread
is CanEqual<Thread>
and CanIterate<Thread>
and CanIndex<int, Thread>
{
	public constant int READY = 0;
	public constant int RUNNING = 1;
	public constant int WAITING = 2;
	public constant int DEAD = 3;
	
	// START: Native methods
	private readonly native spawnThread(Pointer ptr) => (int);
	private readonly native get handleSize() => (int);
	private native get staticNextId() => (int);
	// END: Native methods
	
	// START: Private variables
	nullable Exception ex = null;
	nullable Thread joinThread = null;
	
	int state;
	int joined;
	boolean shouldInterrupt;
	
	Handle handle;
	CanRun runner;
	ThreadSafeList<Thread> childrenList;
	
	Mutex mutex;
	Mutex stateMutex;
	
	Signaler signaler;
	Mailbox mailbox;
	// END: Private variables
	
	/**
	* Gets the Shadow-specific thread ID.
	*/
	get int id;
	
	/**
	* Gets the {@code Thread} which spawned this thread. The Main thread does not
	* have a parent, and is null.
	*/
	get nullable Thread parent = null;
	
	/**
	* Gets the name of the thread set at spawn time. If no name is set
	* at spawn time, the name takes the format "Thread#{id}".
	*/
	get String name;

	/**
	* Gets whether this thread is running.
	*
	* @return {@code true} if the thread is alive; otherwise, {@code false}.
	*/
	public readonly get isAlive() => (boolean)
	{
		return (this->state != DEAD);
	}
	
	public readonly get state() => (int)
	{
		stateMutex.lock();
		var state = this:state;
		stateMutex.unlock();
		
		return state;
	}
	
	public set state(int state) => ()
	{
		stateMutex.lock();
		this:state = state;
		stateMutex.unlock();
	}
	
	public readonly get childrenCount() => (int)
	{
		return childrenList->size;
	}
	
	/**
	* Creates a new {@code Thread} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread.
	* 
	* @param runner The instance that contains a run function.
	*/
	public create(CanRun runner)
	{
		this(runner, null);
	}
	
	/**
	* Creates a new {@code Thread} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread, and takes a {@code String} which is the name
	* of the thread for reference purposes.
	* 
	* @param runner The instance that contains a run function.
	* @param name The name of the thread.
	*/
	public create(CanRun runner, nullable String name)
	{
		this:id = this->staticNextId;
		this:childrenList = ThreadSafeList<Thread>:create();
		
		try {
			this:name = check(name);
		} recover {
			this:name = "Thread#" # id;
		}
		
		this:joined = 0;
		this:mutex = Mutex:create();
		this:stateMutex = Mutex:create();
		this:signaler = Signaler:create();
		this:mailbox = Mailbox:create(32);
		this:handle = Handle:create(this->handleSize);
		this:state = READY;
		
		if(this:id == 0) {
			this:runner = runner;
			this:state = RUNNING;
			this:handle.free();
		} else {
			this:runner = copy(runner);
			this:parent = curthread();
			addToParent();
			
			// spawn the thread and give it the handle
			spawnThread(handle->ptr);
		}
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates.
	* Joining on a dead thread, or on the main thread has no side effects.
	* If the thread is terminated because of an exception, the exception is thrown
	* when this method is called.
	* 
	* @throws InvalidOperationException if this is the main thread or is the same as the calling thread.
	* @throws ThreadException if the thread terminated due to an exception.
	*/
	public join() => () 
	{
		join(false, Time->InfiniteTimeout);
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates or until it times out.
	* Joining on a dead thread, or on the main thread has no side effects.
	* If the thread is terminated because of an exception, the exception is thrown
	* when this method is called.
	*
	* @param timeout the time to wait for.
	* @return {@code true} if the join returned because of a timeout; otherwise, {@code false}.
	* @throws InvalidOperationException if this is the main thread or is the same as the calling thread.
	* @throws ThreadException if the thread terminated due to an exception.
	*/
	public join(TimeSpan timeout) => (boolean)
	{
		return join(false, timeout);
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates or until it times out.
	* Joining on a dead thread has no side effects. If the thread is terminated because of an exception, 
	* the exception is thrown when this method is called.
	*
	* @param millisecondsTimeout the time to wait for in milliseconds.
	* @return {@code true} if the join returned because of a timeout; otherwise, {@code false}.
	* @throws InvalidOperationException if this is the main thread or is the same as the calling thread.
	* @throws ThreadException if the thread terminated due to an exception.
	*/
	public join(int millisecondsTimeout) => (boolean)
	{
		return join(false, Time.fromMilliSeconds(millisecondsTimeout));
	}
	
	public readonly equal(Thread other) => (boolean) 
	{
		return (this === other);
	}

	public readonly iterator() => (Iterator<Thread>)
	{
		return childrenList.iterator();
	}
	
	public readonly index(int index) => (Thread)
	{
		return childrenList[index];
	}
	
	public interrupt() => ()
	{
		shouldInterrupt = true;

		mutex.lock();
		try {
			if(this->state != WAITING) {
				throw InvalidOperationException:create("Cannot interrupt a thread which is not in the WAITING state.");
			}
			
			// the interrupt method will raise an exception inside the running thread.
			try {
				// This block is executed if the thread is waiting for another thread
				// to terminate. The join() method that the thread called will throw
				// the exception.
				check(joinThread):signaler.interrupt(this);
			} recover {
				// This block is executed if the thread is sleeping using the sleep() method.
				signaler.interrupt(this);
			}
			
			// When the InterruptedException is raised, the runnerNative() catches that exception. 
			// Just like any other exception, `ex` is set to that exception, and runnerNative() then cleans
			// up the resources it used. It calls signaler.free(), which in turn causes Signaler to release
			// all the threads it is holding through a waitForNotify(). Since all threads get woken up after
			// the exception `ex` has been set, all the joined thread also get an InterruptedException, and
			// the tree unrwaps correctly.
		} finally {
			mutex.unlock();
		}
	}
	
	private addToParent() => () 
	{
		check(parent):childrenList.add(this);
	}
	
	private setState(int state, nullable Thread joinThread) => ()
	{
		stateMutex.lock();
		this:state = state;
		this:joinThread = joinThread;
		stateMutex.unlock();
	}
	
	// TODO: WE NEED TO MAKE SURE THAT THE ACTUAL UNMANAGED POINTER HAS BEEN FREED
	// Do we need to call pthread_exit()? Gotta figure this out.
	private join(boolean finalizing, TimeSpan timeout) => (boolean)
	{
		if(this === System->mainThread) {
			throw InvalidOperationException:create("A thread cannot call join on the main thread.");
		}
		
		if(this === curthread()) {
			throw InvalidOperationException:create("A thread cannot call join on itself.");
		}
		
		mutex.lock();
		boolean throwException = !finalizing or (finalizing and joined == 0);
		joined += 1;
		mutex.unlock();
		
		boolean timedOut = false;
		if(isAlive()) {
			curthread():joinThread = this;
			curthread()->state = WAITING;

			try {
				checkForInterrupt(false);

				if(timeout->isPositive) {
					timedOut = signaler.waitForNotify(timeout);
				} else {
					signaler.waitForNotify();
				}
			} catch(InterruptedException e) {
				mutex.lock();
				joined -= 1;
				mutex.unlock();

				throw e;
			} finally {
				curthread()->state = RUNNING;
				curthread():joinThread = null;
			}
		}

		// we then check here if we have an exception. If we do, we throw it, and
		// it is the job of runnerNative() to take care of the handling.
		if(throwException and ex !== null) {
			throw check(ex);
		}

		return timedOut;
	}
	
	private sleepNative(TimeSpan timeout) => ()
	{
		// sleep can only be called from the current thread
		// so we just set its state to waiting, and sleep
		this->state = WAITING;
		
		signaler.sleep(timeout);
		
		// 
		checkForInterrupt(true);
	}
	
	private sleepNative(int milliseconds) => ()
	{
		// sleep can only be called from the current thread
		// so we just set its state to waiting, and sleep
		this->state = WAITING;
		
		signaler.sleep(milliseconds);
		
		// this checks for the 
		checkForInterrupt(true);
	}
	
	private checkForInterrupt(boolean shouldSetState) => ()
	{
		mutex.lock();
		try {
			if(shouldInterrupt) {
				throw InterruptedException:create();
			}
		} finally {
			if(shouldSetState) {
				this->state = RUNNING;
			}
			mutex.unlock();
		}
	}
	
	/**
	* This method is natively executed from the newly spawned thread.
	* !!DO NOT MANUALLY EXECUTE!!
	*/
	private runnerNative() => ()
	{
		try {
			this->state = RUNNING;
			runner.run();
		} catch(Exception e) {
			ex = ThreadException:create(this, e);
		} finally {
			this->state = DEAD;

			mutex.lock();
			handle.free();
			signaler.free();
			mutex.unlock();
		}
	}
	
	private waitForThreadsNative() => ()
	{
		// we keep two queues, since we would like to throw the exceptions
		// at the very end. First we traverse the children of all the threads,
		// and when there is an exception, we add it to the exceptionQueue.
		var exceptionQueue = ArrayDeque<ThreadException>:create();

		// queue used for traversal of the children
		var threadsQueue = ArrayDeque<Thread>:create();
		threadsQueue.addLast(System->mainThread);

		while(!threadsQueue.isEmpty()) {
			var thread = threadsQueue.removeFirst();

			// we do not wanna perform any operations on the main thread
			// so we skip if id is zero.
			if(thread->id > 0) {
				try {
					// this join does not do anything if the thread had
					// been joined on before.
					thread.join(true, Time->InfiniteTimeout);
				}
				catch (ThreadException e) {
					exceptionQueue.addLast(e);
				}
			}

			// traverse the children and add them to queue.
			foreach(var child in thread:childrenList) {
				threadsQueue.addLast(child);
			}
		}

		// traverse the exceptions, if any and print them as Uncaught Thread Exceptions.
		while(!exceptionQueue.isEmpty()) {
			Console.printErrorLine("Uncaught " # exceptionQueue.removeFirst());
		}
	}
	
	private readonly createNative() => (Thread) 
	{ 
		return Thread:create(NopRunner:create(), "Thread#main"); 
	}
	
	private receiveNative(Class expectedType) => (Object, Thread)
	{
		return mailbox.dequeue(expectedType);
	}
	
	private receiveNative(Class expectedType, Thread from) => (Object)
	{
		return mailbox.dequeue(expectedType, from);
	}
	
	private sendNative(Object data) => ()
	{
		if(!isAlive()) {
			throw InvalidOperationException:create("Cannot send a message to a dead thread.");
		}
		
		mailbox.enqueue(data);
	}
	
	// A Runner which performs no operations.
	private class NopRunner
		is CanRun
	{
		public run() => () {}
	}
}