import shadow:utility;
import shadow:natives;
import shadow:io@Console;

/**
 * Class {@code Thread} provides ways to manipulate threads. 
 * All threads are required to terminate for the main process to terminate as well.
 * If the main method returns and there are still running threads, 
 *
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Thread
is CanEqual<Thread>
and CanIndex<int, Thread>
{
	public constant int READY = 0;
	public constant int RUNNING = 1;
	public constant int WAITING = 2;
	public constant int DEAD = 3;
	
	// START: Native methods
	private readonly native spawnThread() => (ShadowPointer);
	private native get staticNextId() => (int);
	// END: Native methods
	
	// START: Private variables
	nullable Exception ex = null;
	nullable SignalToken interruptToken = null;
	
	int state;
	int joined;
	boolean interrupting;

	ShadowPointer handle;
	CanRun runner;
	
	ThreadSafeList<Thread> childrenList;
	CanIterate<Thread> childrenIterate;
	CanIterate<Thread> childrenIterateRecurse;
	
	Mutex mutex;
	Mutex stateMutex;
	
	Signaler signaler;
	Mailbox mailbox;
	// END: Private variables
	
	/// Gets the Shadow-specific thread ID.
	get int id;
	
	/// Gets the main thread, which is the root of all threads.
	public readonly native get main() => (Thread);
	
	/**
	* Gets the {@code Thread} which spawned this thread. The Main thread does not
	* have a parent, and is null.
	*/
	get nullable Thread parent = null;
	
	/**
	* Gets the name of the thread set at spawn time. If no name is set
	* at spawn time, the name takes the format "Thread#{id}".
	*/
	get String name;
	
	/**
	* Gets whether this thread is running.
	*
	* @return {@code true} if the thread is alive; otherwise, {@code false}.
	*/
	public readonly get isAlive() => (boolean)
	{
		return (this->state != DEAD);
	}
	
	private set state(int state) => ()
	{
		stateMutex.lock();
		this:state = state;
		stateMutex.unlock();
	}
	
	/// Gets the state of this thread. It can be one of {@code READY}, {@code RUNNING}, {@code WAITING}, or {@code DEAD}.
	public readonly get state() => (int)
	{
		stateMutex.lock();
		var state = this:state;
		stateMutex.unlock();
		
		return state;
	}
	
	/// Gets the string representation of the state of this thread.
	public readonly get stateStr() => (String)
	{
		switch(this->state) {
			case (READY)
				return "READY";
			
			case (RUNNING)
				return "RUNNING";
				
			case (WAITING)
				return "WAITING";
				
			case (DEAD)
				return "DEAD";
		}
		
		throw InvalidOperationException:create("Invalid state");
	}
	
	/**
	* Creates a new {@code Thread} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread.
	* 
	* @param runner The instance that contains a run function.
	*/
	protected create(CanRun runner)
	{
		this(runner, null);
	}
	
	/**
	* Creates a new {@code Thread} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread, and takes a {@code String} which is the name
	* of the thread for reference purposes.
	* 
	* @param runner The instance that contains a run function.
	* @param name The name of the thread.
	*/
	protected create(CanRun runner, nullable String name)
	{
		this:id = this->staticNextId;
		this:childrenList = ThreadSafeList<Thread>:create();
		
		try {
			this:name = check(name);
		} recover {
			this:name = "Thread#" # id;
		}
		
		this:joined = 0;
		this:mutex = Mutex:create();
		this:stateMutex = Mutex:create();
		this:signaler = Signaler:create();
		
		// initialize the mailbox with an initial capacity of 8, and a max capacity of 32.
		// the mailbox doubles as more items are sent to it, until it reaches 32, and blocks
		// if more items are added, until space becomes available again by receiving messages.
		this:mailbox = Mailbox:create(8, 32);
		
		this:state = READY;
		
		this:childrenIterate = TraverseChildren:create(false);
		this:childrenIterateRecurse = TraverseChildren:create(true);
		this:runner = runner;
		
		if(this:id == 0) {
			this:state = RUNNING;
			this:handle = ShadowPointer:create();
		} else {
			this:parent = currentThread();
			check(parent):childrenList.add(instance());
			
			this:handle = spawnThread();
			if(!this:handle->isValid) {
				throw ThreadSpawnException:create();
			}
			
			sleep(1);
		}
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates.
	* Joining on a dead thread has no side effects. If the thread is terminated because of an exception, 
	* the exception is thrown when this method is called.
	* 
	* @throws InvalidOperationException if this thread is the main thread or is the same as the calling thread.
	* @throws ThreadException if the thread terminated due to an exception.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*
	* @seeDoc shadow:standard@ThreadException
	*/
	public join() => ()
	{
		join(false, Time->InfiniteTimeout);
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates or until it times out.
	* Joining on a dead thread has no side effects. If the thread is terminated because of an exception, 
	* the exception is thrown when this method is called.
	*
	* @param timeout the time to wait for.
	* @return {@code true} if the join returned because of a timeout; otherwise, {@code false}.
	*
	* @throws InvalidOperationException if this thread is the main thread or is the same as the calling thread.
	* @throws ThreadException if the thread terminated due to an exception.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*
	* @seeDoc shadow:standard@ThreadException
	*/
	public join(TimeSpan timeout) => (boolean)
	{
		return join(false, timeout);
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates or until it times out.
	* Joining on a dead thread has no side effects. If the thread is terminated because of an exception, 
	* the exception is thrown when this method is called.
	*
	* @param millisecondsTimeout the time to wait for in milliseconds.
	* @return {@code true} if the join returned because of a timeout; otherwise, {@code false}.
	*
	* @throws InvalidOperationException if this thread is the main thread or is the same as the calling thread.
	* @throws ThreadException if the thread terminated due to an exception.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*
	* @seeDoc shadow:standard@ThreadException
	*/
	public join(int millisecondsTimeout) => (boolean)
	{
		return join(false, Time.fromMilliSeconds(millisecondsTimeout));
	}
	
	private join(boolean finalizing, TimeSpan timeout) => (boolean)
	{
		if(this === main()) {
			throw InvalidOperationException:create("A thread cannot call join on the main thread.");
		}
		
		if(isCurrentThread()) {
			throw InvalidOperationException:create("A thread cannot call join on itself.");
		}
		
		mutex.lock();
		boolean throwException = (!finalizing or joined == 0);
		boolean timedOut = false;
		
		joined += 1;
		mutex.unlock();
		
		if(isAlive()) {
			try {
				if(timeout->isPositive) {
					timedOut = signaler.waitForNotify(timeout);
				} else {
					signaler.waitForNotify();
				}
			} catch(InterruptedException e) {
				// An interrupted join is not succesful, so we decrease its count.
				mutex.lock();
				joined -= 1;
				mutex.unlock();

				throw e;
			}
		}

		// we then check here if we have an exception. If we do, we throw it, and
		// it is the job of runnerNative() to take care of the handling.
		if(ex !== null and throwException) {
			throw check(ex);
		}

		return timedOut;
	}
	
	/**
	* Requests this thread to be interrupted. If the thread is currently in the {@code WAITING} state, 
	* the thread is interrupted and the method that caused the thread to be in the {@code WAITING} state
	* raises an {@code InterruptedException}. The methods which are interruptible are {@code join()}, 
	* {@code sleep()}, {@code send()}, {@code receive()}, and all their overloads.
	* If the thread is not in the {@code WAITING} state, an interrupt flag is set, and the thread is interrupted
	* as soon as one of the above interruptible methods above are called, or when the user calls 
	* {@code CurrentThread.throwIfInterrupting()}, or throws an exception using {@code CurrentThread->interrupting}.
	*/
	public interrupt() => ()
	{
		if(!isAlive()) {
			return;
		}
		
		mutex.lock();
		interrupting = true;
		try {
			if(this->state == WAITING and interruptToken !== null) {
				check(interruptToken).signal();
			}
			
			// Quick explanation on how exceptions propagate:
			// 
			// When the InterruptedException is raised, the runnerNative() catches that exception. 
			// Just like any other exception, `ex` is set to that exception, and runnerNative() then cleans
			// up the resources it used. It calls signaler.free(), which in turn causes Signaler to release
			// all the threads it is holding through a waitForNotify(). Since all threads get woken up after
			// the exception `ex` has been set, all the joined thread also get an InterruptedException correctly.
		} finally {
			mutex.unlock();
		}
	}
	
	/// Implemented for CurrentThread->interrupting.
	protected get interrupting() => (boolean)
	{
		if(!isCurrentThread()) { // should never reach this
			throw InvalidOperationException:create("interrupting() should only be called from the current thread.");
		}
		
		mutex.lock();
		try {
			if(interrupting) {
				interrupting = false;
				return true;
			}
			
			return false;
		} finally {
			mutex.unlock();
		}
	}

	/**
	* @throws InterruptedException
	* @seeDoc shadow:natives@Signaler
	*/
	private sleep(TimeSpan timeout) => ()
	{
		signaler.waitForTimeout(timeout);
	}
	
	/**
	* @throws InterruptedException
	* @seeDoc shadow:natives@Signaler
	*/
	private sleep(int millisecondsTimeout) => ()
	{
		sleep(Time.fromMilliSeconds(millisecondsTimeout));
	}

	/**
	* Receives data with the desired {@code expectedType}. This method will throw an exception 
	* and will not retrieve the message if the expected type is not the same as the actual one
	* sent by the thread. A thread can send as many messages as it desires, but the receiving thread
	* should always receive the data in the order it was sent, or otherwise an exception is thrown.
	*
	* @throws IncompatibleMessageTypeException If the item attempted to retrieve does not have the same type as expectedType.
	* @throws InterruptedException If this thread was interrupted while waiting on an empty mailbox.
	* @throws IllegalArgumentException If this thread is the same as the from thread.
	* 
	* @seeDoc shadow:standard@Mailbox
	*/
	protected receiveFirst(Class expectedType) => (Object, Thread)
	{
		return mailbox.dequeue(expectedType);
	}
	
	/**
	* Receives data with the desired {@code expectedType} from the desired thread.
	* This method will throw an exception and will not retrieve the message if the
	* expected type is not the same as the actual one sent by the thread. A thread
	* can send as many messages as it desires, but the receiving thread should always
	* receive the data in the order it was sent, or otherwise an exception is thrown.
	*
	* @throws IncompatibleMessageTypeException If the item attempted to retrieve does not have the same type as expectedType.
	* @throws InterruptedException If this thread was interrupted while waiting on an empty mailbox.
	* @throws IllegalArgumentException If this thread is the same as the from thread.
	* 
	* @seeDoc shadow:standard@Mailbox
	*/
	protected receiveFirstFrom(Class expectedType, Thread from) => (Object)
	{
		if(from === this) {
			throw IllegalArgumentException:create("A Thread cannot receive a message from itself.");
		}
		
		return mailbox.dequeue(expectedType, from);
	}
	
	/**
	* Sends the desired data to this thread. This method copies all the data before
	* sending it to this thread. Thus no data is shared between two threads.
	* This is a blocking method, and it will block if the mailbox of this thread is full.
	* The method will immediately unblock when there is space for the item to be
	* deposited in the mailbox. Mailbox is first come first serve, and the threads sending data
	* will unblock in the order they were blocked in.
	*
	* @param data The data to be cloned and sent to this thread.
	* 
	* @throws InterruptedException If this thread was interrupted while waiting on a full mailbox.
	* @throws InvalidOperationException if this thread is dead or is the same as the receiving one.
	*
	* @seeDoc shadow:standard@Mailbox
	*/
	protected sendTo(Object data) => ()
	{
		if(!isAlive()) {
			throw InvalidOperationException:create("Cannot send a message to a dead thread.");
		}
		
		if(isCurrentThread()) {
			throw InvalidOperationException:create("A Thread cannot send a message to itself.");
		}
		
		mailbox.enqueue(data);
	}
	
	/**
	* This method is natively executed from the newly spawned thread.
	* !!DO NOT MANUALLY EXECUTE!!
	*/
	private runnerNative() => ()
	{
		try {
			this->state = RUNNING;
			runner.run();
		} catch(Exception e) {
			ex = ThreadException:create(this, e);
		} finally {
			cleanup();
		}
	}
	
	private cleanup() => ()
	{
		this->state = DEAD;
		mutex.lock();
		handle.free();
		signaler.free();
		mutex.unlock();
	}
	
	/// Gets whether this thread is the current executing thread.
	public readonly get isCurrentThread() => (boolean)
	{
		return (currentThread() === this);
	}
	
	/**
	* Gets the number of children the thread currently has. This method should be used with caution
	* even though it is thread safe. Since a thread can spawn threads at any time, this count can
	* drastically change between each call.
	*
	* @return how many children that thread has
	*/
	public readonly get childrenCount() => (int)
	{
		return childrenList->size;
	}
	
	/**
	* Gets the n-th child that this thread spawned. This is NOT the Shadow-specific id.
	*
	* @param index the index of the child in the range [0, childrenCount).
	* @return the n-th child {@code Thread}.
	*/
	public readonly childAt(int index) => (Thread)
	{
		return childrenList[index];
	}
	
	/**
	* Gets the n-th child that this thread spawned. This is NOT the Shadow-specific id.
	* This is a shortcut to Thread.childAt(), to allow easy indexing of children using Thread[index].
	*
	* @param index the index of the child in the range [0, childrenCount).
	* @return the n-th child {@code Thread}.
	*/
	public readonly index(int index) => (Thread)
	{
		return childAt(index);
	}
	
	/**
	* Gets the children of this thread. If {@code recurse} is true, this method
	* will also traverse the children of the children recursively, until all children
	* have been visited.
	* Care should be taken using this function, as enumerating can throw an exception
	* if the children have changed.
	*
	* @return {@code CanIterate<Thread>} An iterable class to be used with a foreach loop.
	*/
	public readonly children(boolean recurse) => (CanIterate<Thread>)
	{
		if(recurse) {
			return childrenIterateRecurse;
		}
		
		return childrenIterate;
	}
	
	/**
	* Gets the children of this thread. This method only enumerates through the first generation
	* children of this thread. i.e. only the thread that this thread spawned.
	*
	* @return {@code CanIterate<Thread>} An iterable class to be used with a foreach loop.
	*/
	public readonly children() => (CanIterate<Thread>)
	{
		return children(false);
	}
	
	public readonly equal(Thread other) => (boolean) 
	{
		return (this === other);
	}
	
	/**
	* Returns a string with the format: "Thread ({Thread->name}): {Thread->stateStr}". 
	*/
	public readonly toString() => (String)
	{
		return "Thread (" # name # "): " # this->stateStr;
	}
	
	/// Called natively by Signaler, `this` is the CurrentThread->instance.
	/// This code is responsible for throwing InterruptedException in all methods.
	protected setInterruptToken(nullable SignalToken interruptToken) => ()
	{
		int state = RUNNING;
		// checks whether we need to interrupt, and if we do, it resets the interrupt flag
		var interrupting = CurrentThread->interrupting;
		
		if(interrupting) {
			interruptToken = null;
		} else if(interruptToken !== null) {
			state = WAITING;
		}
		
		this:stateMutex.lock();
		this:state = state;
		this:interruptToken = interruptToken;
		this:stateMutex.unlock();
		
		if(interrupting) {
			throw InterruptedException:create();
		}
	}
	
	private readonly currentThread() => (Thread)
	{
		return CurrentThread->instance;
	}
	
	private waitForThreadsNative() => ()
	{
		if(this !== main()) {
			throw Exception:create("waitForThreadsNative() can only be called on the main thread.");
		}
		// this->state = DEAD; // necessary, maybe?
		
		var exceptionQueue = ArrayDeque<ThreadException>:create();
		
		foreach(var thread in children(true)) {
			try {
				thread.join(true, Time->InfiniteTimeout);
				// the `true` causes this thread to wait for the other thread
				// to terminate and it will only throw an exception if the target 
				// thread had not been joined on before.
			} catch (ThreadException e) {
				exceptionQueue.addLast(e);
			}
		}

		// traverse the exceptions, if any and print them as Uncaught Thread Exceptions.
		while(!exceptionQueue.isEmpty()) {
			Console.printErrorLine("Uncaught " # exceptionQueue.removeFirst());
		}
	}
	
	private readonly createMainNative() => (Thread) 
	{
		return Thread:create(NopRunner:create(), "Thread#main"); 
	}
	
	/// {Thread:this} does not work to get the outer reference, so we use this
	/// workaround instead.
	private readonly instance() => (Thread)
	{
		return this;
	}
	
	// A Runner which performs no operations. A null runner would had been prefered
	// but Shadow does not currenly support nullable interfaces, so until then, this is
	// the most elegant solution.
	private class NopRunner
		is CanRun
	{
		public run() => () {}
	}
	
	private class TraverseChildren is CanIterate<Thread>
	{
		boolean recurse;
		
		public create(boolean recurse)
		{
			this:recurse = recurse;
		}
		
		public readonly iterator() => (Iterator<Thread>)
		{
			if(recurse) {
				return RecursiveChildrenIterator:create();
			}

			return instance():childrenList.iterator();
		}
		
		private class RecursiveChildrenIterator is Iterator<Thread>
		{
			ArrayDeque<Thread> threadsQueue;
			Thread current;
			
			public create()
			{
				threadsQueue = ArrayDeque<Thread>:create();
				current = instance();
			}
			
			public readonly hasNext() => (boolean)
			{
				return (!threadsQueue.isEmpty() or current->childrenCount > 0);
			}
			
			public next() => (Thread)
			{
				// this is tricky as we need to avoid race conditions, and since the parent
				// can spawn threads at any time, we cannot predict when it will happen. We
				// add the first generation children of the current thread to the queue, retrieve
				// the first child, set it as the current, and return it. This allows us to perform
				// operations on the `current` thread outside the iterator, and the children will
				// then be added to queue on demand. Check waitForThreadsNative() for a better understanding.
				addChildrenToQueue(current);
				
				if(threadsQueue.isEmpty()) {
					throw NoSuchElementException:create();
				}
				
				current = threadsQueue.removeFirst();
				return current;
			}
			
			private addChildrenToQueue(Thread parent) => ()
			{
				foreach(var child in parent.children()) {
					threadsQueue.addLast(child);
				}
			}
		}
	}
}