import shadow:utility;

class shadow:standard@
	MessageQueue
is CanIndex<int, Message>
and CanIndexStore<int, Message>
{
	nullable Message[] elements;
	int start;
	int version;
	int maxCapacity;
	
	get int size;
	
	public create(int size)
	{
		this(size, size);
	}
	
	public create(int initialCapacity, int maxCapacity)
	{
		if(initialCapacity > maxCapacity) {
			throw IllegalArgumentException:create("{maxCapacity: " # maxCapacity # "} should be greater than or equal to {initialCapacity: " # initialCapacity # "}.");
		}
		
		this:elements = Message:null[initialCapacity];
		
		this:start = 0;
		this:version = 0;
		this:maxCapacity = maxCapacity;
		this:size = 0;
	}
	
	/**
	* Gets whether the backing array is full. If it is, it tries to double its size.
	* If the new size is bigger than the maxCapacity, the array is set to the maxCapacity.
	* 
	* @return {@code true} if this array cannot grow more and reached maxCapacity; otherwise, {@code false}.
	*/
	public get isFull() => (boolean)
	{
		if (size == elements->size) {
			if(size == maxCapacity) {
				return true;
			}

			int newSize = elements->size * 2;
			if(newSize > maxCapacity) {
				newSize = maxCapacity;
			}

			nullable Message[] temp = Message:null[newSize];
			for(int i = 0; i < size; i += 1) {
				temp[i] = this[i];
			}

			elements = temp;
			start = 0;
		}
		
		return false;
	}
	
	public readonly get isEmpty() => (boolean)
	{
		return (size == 0);
	}
	
	public indexOf(Thread thread) => (int index)
	{
		for(int i = 0; i < size; i += 1) {
			if(thread === this[i]->sender) {
				return i;
			}
		}

		return -1;
	}

	public enqueue(Message message) => ()
	{
		if(isFull()) {
			throw FullListException:create();
		}

		size += 1;
		this[size - 1] = message;
		
		version += 1;
	}
	
	public dequeue(Class expectedType) => (Message)
	{
		return removeAt(0, expectedType);
	}
	
	/**
	* This does not remove the item if it is not the same as the expectedType.
	*/
	public removeAt(int index, Class expectedType) => (Message)
	{
		// retrieve the data and make sure that it is the same as the expectedType.
		// the indexer also checks for out of bounds exception, so we do not need
		// to worry about that.
		var message = this[index];
		var dataType = message->data.getClass();
		if(dataType !== expectedType) {
			throw WrongTypeException:create(expectedType, dataType);
		}
		
		if(index == 0) {
			nullify(0);
			start = (start + 1) % elements->size;
		} else {
			// we shift the array by one to the left.
			// assuming we are deleting the second item:
			// [1, 2, 3, 4, 5] -> [1, 3, 4, 5, null]
			// (   size = 5  ) -> (    size = 4    )
			for(int i = index; i < size - 1; i += 1) {
				this[i] = this[i + 1];
			}
			
			// set the last item to null since it is not used anymore
			nullify(size - 1);
		}
		
		// decrease the size, since we deleted the item.
		size -= 1;
		
		// if the list is empty, we can start at zero again.
		if(isEmpty()) {
			start = 0;
		}
		
		version += 1;
		
		return message;
	}
	
	// CanIndex<int, Message>
	public readonly index(int index) => (Message)
	{
		return check(elements[rawIndex(index)]);
	}
	
	// CanIndexStore<int, Message>
	public index(int index, Message message) => ()
	{
		elements[rawIndex(index)] = message;
	}
	
	private nullify(int index) => ()
	{
		elements[rawIndex(index)] = null;
	}
	
	private readonly rawIndex(int index) => (int)
	{
		if(index < 0 or index >= size) {
			throw IndexOutOfBoundsException:create();
		}

		return ((start + index) % elements->size);
	}
}