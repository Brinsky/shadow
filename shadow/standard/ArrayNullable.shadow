/**
 * Class {@code ArrayNullable<T>} is used as a wrapper for nullable array objects
 * when they must be treated as objects.
 *
 * The object keeps a reference to normal array memory as well as additional
 * dimension information needed to access the array safely. 
 *
 * Most of the use of {@code NullableArray<T>} is handled by the compiler.
 * Users should avoid using the {@code NullableArray<T>} type explicitly 
 * unless absolutely necessary. 
 * 
 * In this implementation, most methods of {@code NullableArray<T>} are implemented
 * as aliases to the parallel method in {@code Array<T>}, since the mechanics
 * differ in only a few cases. 
 */

abstract locked class shadow:standard@
	ArrayNullable<T>
is  CanIndexNullable<long,T>
and CanIndexStoreNullable<long,T>
and CanIterateNullable<T>
{	
	Object[] data; //not actually objects, but can be treated as such except for arrays, interfaces, and primitives
	
	/**
	 * Creates an {@code ArrayNullable<T>} wrapper for the given array.	 
	 * This method is called internally by the compiler and is only {@code protected}
	 * because it allows other classes to see the method.
	 */
	protected native create( Object[] data );
		
	/**
	 * Creates an {@code Array<T>} object with the given size.
	 * This method is called internally by the compiler and is only {@code protected}
	 * because it allows other classes to see the method.
	 */
	//protected native create( long size );
	
	public native destroy;
	
	/**
	 * Gets the size of the array (total number of elements) as an {@code int}.
	 * @return size of array
	 */
	public readonly native get size() => ( int );
	
	/**
	 * Gets the size of the array (total number of elements) as a {@code long}.
	 * @return size of array
	 */
	public readonly native get longSize() => ( long );	
	
	/**
	 * Copy a subarray from the given array, starting at {@code start} and going
	 * up to but not including index {@code end}.
	 * The resulting array will always be one-dimensional and requires an explicit
	 * cast in order to be stored back into a normal array reference.
	 * @param start	starting index of subarray
	 * @param end	index after last index in subarray
	 * @return {@code ArrayNullable<T>} object containing the subarray
	 */		
	public native readonly subarray( long start, long end ) => ( ArrayNullable<T> );
	
	
	/**
	 * Gets element located at the specified index.
	 * @param index	location to read from, as a {@code long}	 
	 * @return value at given location
	 */	
	public readonly native index( long index ) => (T);

	
	/**
	 * Sets element at the specified index to the given value.
	 * @param index	location to store at	 
	 * @param value value to be stored
	 */	
	public native index( long index, nullable T value ) => ();

	
	/**
	 * Gets formatted {@code String} representation of the array.   
	 * @return {@code String} representation
	 */
	public readonly toString() => ( String )
	{
		if ( this->size == 0 )
			return "[]";
		
		MutableString string = MutableString:create("[");
		boolean first = true;
		foreach( nullable T value in this )
		{	
			if ( first )
				first = false;
			else
				string.append(", ");
				
			string.append(value);
		}
		return string.append("]").toString();
	}
	
	/**
	 * Gets iterator that can iterate over all the elements of the array.   
	 * @return iterator
	 */
	public readonly iterator() => (IteratorNullable<T>)
	{
		return ArrayIterator:create();
	} 
	
	private class ArrayIterator is IteratorNullable<T>
	{
		long position = 0;
		long limit = longSize();
		
		public readonly hasNext() => (boolean)
		{	
			return position < limit;		
		}
		
		public next() => (nullable T)
		{
			if( position >= limit )
				throw IndexOutOfBoundsException:create();
			
			nullable T value = index( position );			
			position += 1L;			
			
			return value;  
		}
	}
}
