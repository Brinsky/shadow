/**
 * Class {@code Array<T>} is used as a wrapper for array objects when
 * they must be treated as objects.
 *
 * The object keeps a reference to normal array memory as well as additional
 * dimension information needed to access the array safely. 
 *
 * Most of the use of {@code Array<T>} is handled by the compiler.
 * Users should avoid using the {@code Array<T>} type explicitly 
 * unless absolutely necessary.
 */
abstract locked class shadow:standard@
	Array<T>
is CanIndex<long,T>
and CanIndexStore<long,T>
and CanIterate<T>
{
	Object[] data; //not actually objects, but can be treated as such except for arrays, interfaces, and primitives
	
	/**
	 * Creates an {@code Array<T>} wrapper for the given array. 
	 * This method is called internally by the compiler and is only {@code protected}
	 * because it allows other classes to see the method.
	 */
	protected native create( Object[] data );
	
	/**
	 * Creates an {@code Array<T>} object with the given size.
	 * This method is called internally by the compiler and is only {@code protected}
	 * because it allows other classes to see the method.
	 */
	//protected native create( long size );
	
	public native destroy;

	/**
	 * Gets the size of the array (total number of elements) as an {@code int}.
	 * @return size of array
	 */
	public readonly get size() => ( int )
	{
		return cast<int>(sizeLong());
	}
	
	/**
	 * Gets the size of the array (total number of elements) as a {@code long}.
	 * @return size of array
	 */
	public readonly native get sizeLong() => ( long );	

	/* 
	// Copy implementation based off the following code:
	private readonly copyProxy(AddressMap addresses) => ( Array<T> )
	{
		Array<T> duplicate = Array<T>:create( lengths );
		for( int i = 0; i < this->size; i += 1 )
			duplicate.index(i, index(i).copy(addresses)));
				
		return duplicate;
	}
	*/
	
	/**
	 * Copy a subarray from the given array, starting at {@code start} and
	 * going up to but not including index {@code end}.
	 * The resulting array will require an explicit cast in order to be stored
	 * back into a normal array reference.
	 * @param start	starting index of subarray
	 * @param end	index after last index in subarray
	 * @return {@code Array<T>} object containing the subarray
	 */	
	public readonly native subarray( long start, long end ) => ( Array<T> );
	
	/**
	 * Gets element located at the specified index.
	 * @param index	location to read from, as a {@code long}	 
	 * @return value at given location
	 */	
	public readonly native index( long index ) => (T);

	
	/**
	 * Sets element at the specified index to the given value.
	 * @param index	location to store at	 
	 * @param value value to be stored
	 */	
	public native index( long index, T value ) => ();

	/**
	 * Gets formatted {@code String} representation of the array.   
	 * @return {@code String} representation
	 */
	public readonly toString() => ( String )
	{
		if ( this->sizeLong == 0L )
			return "[]";

		MutableString string = MutableString:create("[");
		boolean first = true;		
		
		foreach( T value in this )
		{
			if ( first )
				first = false;
			else
				string.append(", ");
				
			string.append( #value );
		}
		
		return string.append("]").toString();
	}
	
	/**
	 * Gets iterator that can iterate over all the elements of the array.   
	 * @return iterator
	 */
	public readonly iterator() => (Iterator<T>)
	{		
		return ArrayIterator<T>:create(this);
	} 
	
	private class ArrayIterator<T> is Iterator<T>
	{
		long position = 0L;
		immutable long limit;
		Array<T> array;
		
		public create(Array<T> array)
		{			
			this:array = array;
			limit = array->sizeLong;
		}
		
		public readonly hasNext() => (boolean)
		{	
			return position < limit;		
		}
		
		public next() => (T)
		{		
			
			if( position >= limit )
				throw IndexOutOfBoundsException:create(position);			
			T value = array.index( position );						
			position += 1L;			
			
			return value;  
		}
	}
}
