/**
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Handle
{
	// the raw memory address is stored instead of an object to avoid any problems
	// with cloning any handle using copy() or freeze().  A Handle, however, should
	// never be cloned since its contents will always point to the same location in memory
	// and freeing the same block of memory from different handles can cause side effects and crashes.
	long handle;
	
	private native readonly createHandle(int size) => (long handle);
	private native readonly freeHandle(Pointer ptr) => ();
	private native readonly getPtrFromLong(long handle) => (Pointer ptr);

	/**
	* Creates an invalid handle. This does not allocate any extra memory.
	*/
	public create()
	{
		this:handle = 0;
	}
	
	/**
	* Allocates a block of memory on the heap which is {@code size} bytes long, 
	* and initializes all its bits to zero.
	*
	* @param {@code size} The size, in bytes, that needs to be allocated on the heap.
	*/
	public create(int size)
	{
		if(size <= 0) {
			throw IllegalArgumentException:create("The {size} of the memory that will be allocated should be bigger than zero.");
		}
		
		this:handle = createHandle(size);
	}

	/**
	* This is the actual pointer to the handle. We use an Object to represent the pointer
	* as it cannot be dereferenced in Shadow, and can be easily cast to anything in LLVM.
	* This reference should only be passed to other native methods which will use that handle,
	* and should not be stored in a variable in Shadow.
	* 
	* @return {@code Pointer} The raw pointer to the handle.
	*
	* @throws {@code InvalidOperationException} if the handle has been freed or is not valid.
	*/
	public readonly get ptr() => (Pointer ptr)
	{
		if(!this->isValid) {
			throw InvalidOperationException:create("This handle is no longer valid.");
		}
		
		return getPtrFromLong(handle);
	}
	
	/**
	* Gets whether this handle is valid.
	*
	* @return {@code true} if the handle is valid; otherwise, {@code false}.
	*/
	public get readonly isValid() => (boolean)
	{
		return (handle != 0);
	}
	
	/**
	* Frees the memory allocated by this handle. Calling this method more than once does
	* not have any side effects.
	*/
	public free() => () 
	{
		if(this->isValid) {
			freeHandle(this->ptr);
			handle = 0;
		}
	}
}