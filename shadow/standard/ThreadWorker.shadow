import shadow:io@Console;
import shadow:utility@LinkedList;

locked class shadow:standard@
	ThreadWorker
{
	locked class ThreadData is CanEqual<ThreadData> {
		get Object data;
		get ThreadWorker sender;
		
		public create(Object data, ThreadWorker sender) {
			this:data = data;
			this:sender = sender;
		}
		
		public readonly equal(ThreadData other) => (boolean) {
			return (data === other:data and sender === other:sender);
		}
	}
	
	// START: Native methods
	private createNative() => (ThreadWorker) { return ThreadWorker:create(); }
	private native createHandle() => (nullable Object);
	private native freeHandle(nullable Object handle) => ();
	private native spawnThread(nullable Object handle) => (int);
	private native joinThread(nullable Object handle) => (int);
	private native getNextId() => (int);
	// END: Native methods	
	
	/**
	* This is the os-specific handle, and cannot be dereferenced in Shadow.
	* However, it is not null when the thread is running, and is null when
	* the thread is dead. So, it can be evaluated to see whether a thread is running.
	*/
	nullable Object handle = null;
	
	nullable Exception ex = null;
	
	/// The runner instance which will be used by the newly spawned thread.
	CanRun runner;
	
	/**
	* Gets the Shadow-specific thread ID.
	*/
	get int id;
	
	/**
	* Gets the {@code ThreadWorker} which spawned this thread.
	*/
	get nullable ThreadWorker parent;
	
	/**
	* Gets the name of the thread set at spawn time. If no name is set
	* at spawn time, the name takes the format "Thread#{id}".
	*/
	get String name;
	
	/**
	* Gets whether this thread is running.
	*/
	public get isRunning() => (boolean)
	{
		return (name == "main" or handle !== null);
	}
	
	/**
	* !Used natively!
	*
	* This method is only used to create a thread for the main
	* thread. The main thread needs an instance as well.
	*/
	private create()
	{
		this:runner = NopRunner:create();
		this:id = getNextId();
		this:parent = null;
		this:name = "Thread#main";
	}
	
	/**
	* Creates a new {@code ThreadWorker} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread.
	* 
	* @param runner The instance that contains a run function.
	*/
	public create(CanRun runner)
	{
		this(runner, null);
	}
	
	/**
	* Creates a new {@code ThreadWorker} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread, and takes a {@code String} which is the name
	* of the thread for reference purposes.
	* 
	* @param runner The instance that contains a run function.
	* @param name The name of the thread.
	*/
	public create(CanRun runner, nullable String name)
	{
		this:runner = copy(runner);
		this:id = getNextId();
		this:parent = Thread->current;
		
		try {
			this:name = check(name);
		}
		recover {
			this:name = "Thread#" # id;
		}
		
		// spawnThread natively sets the handle
		this:handle = createHandle();
		spawnThread(handle);
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates. 
	* Joining on a dead thread, or on the main thread has no side effects.
	* 
	* @throws InvalidOperationException if the calling thread is the same as this thread.
	*/
	public join() => ()
	{
		if(this === Thread->current)
			throw InvalidOperationException:create("A thread cannot call join on itself.");
		
		if(handle !== null) {
			joinThread(handle);
		}
		
		try {
			throw check(ex);
		} recover {}
	}
	
	/**
	* !Used natively!
	*
	* This method is natively executed from the newly spawned thread.
	* DO NOT MANUALLY EXECUTE.
	*/
	private runnerNative() => ()
	{
		try {
			runner.run();
		} catch(Exception e) {
			ex = e;
		} finally {
			// natively free of the handle
			freeHandle(handle);
			handle = null;
		}
	}
	
	// A Runner which performs no operations.
	private class NopRunner
		is CanRun
	{
		public run() => () {}
	}
}