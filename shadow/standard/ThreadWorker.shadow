import shadow:io@Console;
import shadow:utility@ReadOnlyList;
import shadow:utility@List;
import shadow:utility@ArrayDeque;

locked class shadow:standard@
	ThreadWorker
is CanEqual<ThreadWorker>
{
	// START: Native methods
	private createNative() => (ThreadWorker) { return ThreadWorker:create(NopRunner:create(), "Thread#main"); }
	private unlockMutexNative() => () { mutex.unlock(); }

	private native createHandle() => (nullable Object);
	private native freeHandle(nullable Object handle) => ();

	private native spawnThread(nullable Object handle) => (int);
	private native joinThread(Object handle) => (int);
	
	private native get staticNextId() => (int);
	// END: Native methods
	
	// START: Private variables
	/**
	* This is the os-specific handle, and cannot be dereferenced in Shadow.
	* However, it is not null when the thread is running, and is null when
	* the thread is dead. So, it can be evaluated to see whether a thread is running.
	*/
	nullable Object handle = null;
	nullable Exception ex = null;
	
	boolean joined = false;
	Mutex mutex;
	CanRun runner;
	ThreadSafeList<ThreadWorker> childrenList;
	// END: Private variables
	
	/**
	* Gets the Shadow-specific thread ID.
	*/
	get int id;
	
	/**
	* Gets the {@code ThreadWorker} which spawned this thread.
	*/
	get nullable ThreadWorker parent = null;
	
	/**
	* Gets the name of the thread set at spawn time. If no name is set
	* at spawn time, the name takes the format "Thread#{id}".
	*/
	get String name;
	
	/**
	* Gets the list of threads spawned by this thread.
	*/
	//get ThreadSafeList<ThreadWorker> children;
	//get ReadOnlyList<ThreadWorker> children;
	
	/**
	* Gets whether this thread is running.
	*/
	public get isRunning() => (boolean)
	{
		boolean running;
		
		mutex.lock(); {
			running = (handle !== null or id == 0);
		} mutex.unlock();
		
		return running;
	}

	/**
	* Creates a new {@code ThreadWorker} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread.
	* 
	* @param runner The instance that contains a run function.
	*/
	public create(CanRun runner)
	{
		this(runner, null);
	}
	
	/**
	* Creates a new {@code ThreadWorker} object which takes on a {@code CanRun}
	* instance, containing a run function that is going to be ran
	* on a different thread, and takes a {@code String} which is the name
	* of the thread for reference purposes.
	* 
	* @param runner The instance that contains a run function.
	* @param name The name of the thread.
	*/
	public create(CanRun runner, nullable String name)
	{
		this:id = this->staticNextId;
		this:childrenList = ThreadSafeList<ThreadWorker>:create();
		//this:children = ReadOnlyList<ThreadWorker>:create(childrenList);
		
		try {
			this:name = check(name);
		}
		recover {
			this:name = "Thread#" # id;
		}
		
		this:mutex = Mutex:create();
		
		if(this:id == 0)
			this:runner = runner;
		else
		{
			this:runner = copy(runner);
			this:parent = Thread->current;
			addToParent();
		}
		
		// we allocate the handle first
		this:handle = createHandle();
		// spawn the thread and give it the handle
		spawnThread(handle);
	}
	
	private addToParent() => () {
		check(parent):childrenList.add(this);
	}
	
	private join(boolean finalizing) => ()
	{
		if(this === Thread->main)
			throw InvalidOperationException:create("A thread cannot call join on the main thread.");
			
		if(this === Thread->current)
			throw InvalidOperationException:create("A thread cannot call join on itself.");
		
		// this process looks complex but is rather simple, first we acquire the lock,
		// so we have an up-to-date version of handle.
		mutex.lock();
		// we check if we're not finalizing, then the user called this method, otherwise,
		// if this thread was not joined on before, we got to join and wait for it to terminate.
		boolean flag = !finalizing or (finalizing and !joined);
		if(flag and handle !== null) {
			joined = true; // at this point, we consider that the thread has been joined.
			Object handle = check(handle);
			
			// joinThread() unlocks the mutex before waiting for the thread to terminate.
			joinThread(handle);
		}
		// we need not to forget to unlock the mutex if we did not actually join thread.
		else { mutex.unlock(); }

		// we then check here if we have an exception. If we do, we throw it, and
		// it is the job of runnerNative() to take care of the handling.
		if(flag and ex !== null) {
			throw check(ex);
		}
	}
	
	/**
	* Suspends the execution of the calling thread until this thread terminates. 
	* Joining on a dead thread, or on the main thread has no side effects.
	* If the thread is terminated because of an exception, the exception is thrown
	* when this {@code join()} method is called.
	* 
	* @throws {@code InvalidOperationException} if this is the main thread or is the same as the calling thread.
	* @throws {@code ThreadException} wraps the exception which caused this thread to terminate, if any.
	*/
	public join() => () {
		join(false);
	}
	
	/**
	* This method is natively executed from the newly spawned thread.
	* DO NOT MANUALLY EXECUTE.
	*/
	private runnerNative() => ()
	{
		try {
			runner.run();
		} catch(Exception e) {
			ex = ThreadException:create(this, e);
		} finally {
			mutex.lock(); {
				// natively free of the handle
				freeHandle(handle);
				
				// the native is invalid now, set it to null
				handle = null;
			} mutex.unlock();
		}
	}
	
	private waitForThreadsNative() => ()
	{
		// we keep two queues, since we would like to throw the exceptions
		// at the very end. First we traverse the children of all the threads,
		// and when there is an exception, we add it to the exceptionQueue.
		var exceptionQueue = ArrayDeque<Exception>:create();
		
		// queue used for traversal of the children
		var threadsQueue = ArrayDeque<ThreadWorker>:create();
		threadsQueue.addLast(Thread->main);
		
		while(!threadsQueue.isEmpty()) {
			var thread = threadsQueue.removeFirst();
			
			// we do not wanna perform any operations on the main thread
			// so we skip if id is zero.
			if(thread->id > 0) {
				try {
					// here, we perform a join, and tell the join that
					// we're finalizing the application.
					thread.join(true);
				} catch (Exception e) {
					exceptionQueue.addLast(e);
				}
			}
			
			// traverse the children and add them to queue.
			foreach(var child in thread:childrenList) {
				threadsQueue.addLast(child);
			}
		}
		
		// traverse the exceptions, if any and print them as Uncaught Thread Exceptions.
		while(!exceptionQueue.isEmpty()) {
			Console.printErrorLine("Uncaught " # exceptionQueue.removeFirst());
		}
	}
	
	public readonly equal(ThreadWorker other) => (boolean) {
		return (this === other);
	}
	
	locked class ThreadData is CanEqual<ThreadData> {
		get Object data;
		get ThreadWorker sender;
		
		public create(Object data, ThreadWorker sender) {
			this:data = data;
			this:sender = sender;
		}
		
		public readonly equal(ThreadData other) => (boolean) {
			return (data === other:data and sender === other:sender);
		}
	}
	
	// A Runner which performs no operations.
	private class NopRunner
		is CanRun
	{
		public run() => () {}
	}
}