import shadow:utility@ArrayDeque;

/**
* @author Claude Abounegm
*/
locked class shadow:natives@
	Signaler
{
	class SignalToken
	{
		get boolean shouldWait = true;
		
		public invalidate() => ()
		{
			shouldWait = false;
		}
	}

	private native readonly initSignaler(Pointer cond) => (int);
	private native readonly destroySignaler(Pointer cond) => (int);
	
	private native readonly wait(Pointer cond, Pointer mutex) => (int);
	private native readonly timedWait(Pointer cond, Pointer mutex, Pointer time) => (int);
	private native readonly broadcast(Pointer cond) => (int);
	
	private readonly native get handleSize() => (int);
	//private native readonly signal(Pointer cond) => (int);
	
	int waitingThreads = 0;
	Mutex mutex;
	Handle condHandle;
	ArrayDeque<SignalToken> tokensQueue;
	
	public create()
	{
		mutex = Mutex:create();
		condHandle = Handle:create(this->handleSize);
		tokensQueue = ArrayDeque<SignalToken>:create();
		
		initSignaler(condHandle->ptr);
	}
	
	public get waitingThreadsCount() => (int)
	{
		mutex.lock();
		var count = waitingThreads;
		mutex.unlock();
		
		return count;
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll().
	*
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify() => () 
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		var token = SignalToken:create();

		mutex.lock();
		tokensQueue.addLast(token);
		waitingThreads += 1;
		
		while(token->shouldWait) {
			// mutex unlocks when waiting
			wait(condHandle->ptr, mutex->ptr);
			// mutex locks back when finished waiting
		}
		
		waitingThreads -= 1;
		mutex.unlock();
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll(), or until the specified amount of time elapsed.
	*
	* @param timeout The amount of time to wait before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify(TimeSpan timeout) => (boolean)
	{
		return waitSleep(timeout, true);
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll(), or until the specified amount of time elapsed.
	*
	* @param millisecondsTimeout The amount of time to wait, in milliseconds, before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify(int millisecondsTimeout) => (boolean)
	{		
		return waitSleep(Time.fromMilliSeconds(millisecondsTimeout), true);
	}
	
	public sleep(TimeSpan time) => () 
	{
		waitSleep(time, false);
	}
	
	public sleep(int ms) => ()
	{		
		waitSleep(Time.fromMilliSeconds(ms), false);
	}
	
	public notify() => () 
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}
		
		mutex.lock();
		// we would like to assure having a more or less organised wake up pattern.
		// Thus, notify should wake the threads up in the order that they went to sleep in.
		// we dequeue the first token, and broadcast to wake up all threads. However, since
		// we're in a loop, only one thread wakes up, which is the one we want.
		if(!tokensQueue.isEmpty()) {
			// we would like to avoid to notify wait which has already timedout.
			// when a wait timesout, it sets its own flag to false, so its token
			// could still be in the queue, but it is invalid and no threads are
			// listening on it. So we check for that. If the flag is false, we ignore
			// it and move on to the next one.
			SignalToken token;
			do {
				token = tokensQueue.removeFirst();
			} while(!tokensQueue.isEmpty() and !token->shouldWait);
			
			// found a valid flag, set to false, and notify it.
			token.invalidate();
			
			broadcast(condHandle->ptr);
		}
		mutex.unlock();
	}
	
	public notifyAll() => ()
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		mutex.lock();
		if(!tokensQueue.isEmpty()) {
			// we set all the wait flags to false
			do {
				tokensQueue
					.removeFirst()
					.invalidate();
			} while(!tokensQueue.isEmpty());

			// wake all the threads up
			broadcast(condHandle->ptr);
		}
		mutex.unlock();
	}
	
	public free() => ()
	{
		if(condHandle->isValid) {		
			mutex.lock();
			if(!tokensQueue.isEmpty()) {
				mutex.unlock();
				throw InvalidOperationException:create("The signaler cannot be freed when there are threads waiting on it.");
			}
			mutex.unlock();
			
			destroySignaler(condHandle->ptr);
			condHandle.free();
			mutex.free();
		}
	}
	
	private waitSleep(TimeSpan timeout, boolean listenToNotify) => (boolean)
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		var time = AbsoluteTime:create(timeout);
		var token = SignalToken:create();

		mutex.lock();		
		if(listenToNotify) {
			tokensQueue.addLast(token);
		}

		int retVal = 0; // retVal is not zero when the wait times out		
		waitingThreads += 1;
		while(retVal == 0 or (listenToNotify and token->shouldWait)) {
			// mutex unlocks when waiting
			retVal = timedWait(condHandle->ptr, mutex->ptr, time->ptr);
			// mutex locks back when finished waiting
		}
		waitingThreads -= 1;

		// we invalidate the token in-case it was still valid due to a timeout.
		token.invalidate();
		time.free();
		mutex.unlock();

		return (retVal != 0);
	}
}