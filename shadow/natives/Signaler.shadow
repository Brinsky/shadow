import shadow:utility;

/**
 * Class {@code Signaler} contains signaling methods to communicate between threads
 * such as: waitForNotify(), waitForTimeout(), notify(), and notifyAll().
 *
 * @author Claude Abounegm
 * @seeDoc shadow:test@SignalerTest
 *
 * @seeDoc shadow:standard@Thread
 */
locked class shadow:natives@
	Signaler
{
	private native readonly initSignaler(Pointer cond) => (int);
	private native readonly destroySignaler(Pointer cond) => (int);
	
	private native readonly wait(Pointer cond, Pointer mutex) => (int);
	private native readonly timedWait(Pointer cond, Pointer mutex, Pointer time) => (int);
	private native readonly broadcast(Pointer cond) => (int);
	
	/**
	* This method sets the interruptToken of the current thread to accompany the {@code Thread.interrupt()} method.
	*/
	private native readonly setInterruptToken(Thread currentThread, nullable SignalToken interruptToken) => ();
	
	private readonly native get handleSize() => (int);
	
	boolean terminate = false;
	int waitingThreads = 0;
	
	Mutex mutex;
	Pointer ptr;
	LinkedList<SignalToken> tokensQueue;
	
	/**
	* Initializes a new {@code Signaler} instance.
	*/
	public create()
	{
		mutex = Mutex:create();
		ptr = Pointer:create(this->handleSize);
		tokensQueue = LinkedList<SignalToken>:create();
		
		initSignaler(ptr);
	}
	
	/**
	* Gets the number of threads that are currently waiting on this Signaler.
	*/
	public readonly get waitingThreadsCount() => (int)
	{
		mutex.lock();
		var count = waitingThreads;
		mutex.unlock();
		
		return count;
	}
	
	/**
	* Suspends the calling thread until another thread calls notify(),
	* notifyAll(), or interrupt(). 
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/
	public waitForNotify() => ()
	{
		ptr.assertValid("Signaler");

		var token = SignalToken:create(this);

		mutex.lock();
		try {
			tokensQueue.addLast(token);
			waitingThreads += 1;
			
			setInterruptToken(CurrentThread->instance, token);
			while(token->shouldWait and !terminate) {
				mutex.giveUpOwnership();
				wait(ptr, mutex->ptr);
				mutex.takeOwnership();
			}
			setInterruptToken(CurrentThread->instance, null);
		} finally {
			waitingThreads -= 1;
			mutex.unlock();
		}
	}
	
	private waitSleep(TimeSpan timeout, boolean sleepOnly) => (boolean)
	{
		ptr.assertValid("Signaler");

		var time = AbsoluteTime:create(timeout);
		var token = SignalToken:create(this);
		int retVal = 0;
		
		mutex.lock();
		try {
			// we only add the token if we want to be able to wake this thread up later.
			// since we do not want any notify to wake that thread up, we do not add it to
			// the queue if we only want to sleep.
			if(!sleepOnly) {
				tokensQueue.addLast(token);
			}

			waitingThreads += 1;
			
			setInterruptToken(CurrentThread->instance, token);
			 // retVal is not zero when the wait times out
			while(retVal == 0 and token->shouldWait and !terminate) {
				mutex.giveUpOwnership();
				retVal = timedWait(ptr, mutex->ptr, time->ptr);
				mutex.takeOwnership();
			}
			setInterruptToken(CurrentThread->instance, null);
		} finally {
			waitingThreads -= 1;
			if(token.invalidate() and !sleepOnly) {
				// waitForNotify timedout, so we still need to remove the 
				// token from the queue.
				tokensQueue.remove(token);
			}
			mutex.unlock();
			time.free();
		}

		return (retVal != 0);
	}
	
	/**
	* Suspends the calling thread until another thread calls notify(),
	* notifyAll(), or for the specified amount of time elapsed.
	*
	* @param timeout The amount of time to wait before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	*/
	public waitForNotify(TimeSpan timeout) => (boolean)
	{
		return waitSleep(timeout, false);
	}
	
	/**
	* Suspends the calling thread until another thread calls notify(),
	* notifyAll(), or for the specified amount of time elapsed.
	*
	* @param millisecondsTimeout The amount of time to wait, in milliseconds, before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/
	public waitForNotify(int millisecondsTimeout) => (boolean)
	{		
		return waitSleep(Time.fromMilliSeconds(millisecondsTimeout), false);
	}
	
	/**
	* Suspends the calling thread for the specified amount of time.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/
	public waitForTimeout(TimeSpan timeout) => ()
	{
		waitSleep(timeout, true);
	}

	/**
	* Suspends the calling thread for the specified amount of time.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/	
	public waitForTimeout(int millisecondsTimeout) => ()
	{		
		waitSleep(Time.fromMilliSeconds(millisecondsTimeout), true);
	}
	
	/**
	* Wakes a thread up, if there is any. Signaler is FIFO, meaning the first thread that
	* went to sleep is the first that gets woken up.
	*
	* @return {@code true} if a thread was woken up; otherwise, {@code false}.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	*/
	public notify() => (boolean) 
	{
		ptr.assertValid("Signaler");
		
		mutex.lock();
		try {
			// we would like to assure having a more or less organised wake up pattern.
			// Thus, notify should wake the threads up in the order that they went to sleep in.
			// we dequeue the first token, and broadcast to wake up all threads. This wakes up all
			// the threads owned by this Signaler, but only one thread actually "really" wakes up. That is
			// due to the SignalToken still being blocking on all threads but the one we unlocked.
			if(!tokensQueue.isEmpty()) {
				return signal(tokensQueue.removeFirst());
			}
		} finally {
			mutex.unlock();
		}
		
		return false;
	}
	
	/**
	* Wakes up all the waiting threads, which were put to sleep using {@code waitForNotify()}.
	* Threads are woken up in the order they were put to sleep. Threads sleeping due to {@code waitForTimeout()}
	* are not woken up, and the only way to wake them up is either by freeing this Signaler or by waiting for them to timeout.
	*
	* @return the number of threads that were woken up.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	*/
	public notifyAll() => (int)
	{
		ptr.assertValid("Signaler");

		mutex.lock();
		int count = 0;
		try {
			while(!tokensQueue.isEmpty()) {
				if(signal(tokensQueue.removeFirst())) {
					count += 1;
				}
			}
		} finally {
			mutex.unlock();
		}
		
		return count;
	}
	
	/**
	* Frees the allocated resources of the Signaler. All waiting threads are
	* woken up before freeing the resources. This includes threads that were
	* put to sleep using the waitForTimeout() method. Calling {@code free()} more
	* than once has no effect.
	*/
	public free() => ()
	{
		if(ptr->isValid) {
			// empties the queue and notifies the threads in the order
			// they were put to sleep in.
			notifyAll();
			
			// if there are any sleeping threads, then they aren't in the queue
			// so we set a global terminate flag, and broadcast to the rest of the threads.
			terminate = true;
			broadcast(ptr);
			
			// free the allocated memory
			destroySignaler(ptr);
			ptr.free();
			mutex.free();
		}
	}
	
	private signal(SignalToken token) => (boolean)
	{
		if(token.invalidate()) {
			broadcast(ptr);
			return true;
		}
		
		return false;
	}
	
	private signalNative(SignalToken token) => ()
	{
		ptr.assertValid("Signaler");
		
		mutex.lock();
		try {
			tokensQueue.remove(token);
			signal(token);
		} finally {
			mutex.unlock();
		}
	}
}