import shadow:utility@ArrayDeque;

/**
* @author Claude Abounegm
*/
locked class shadow:natives@
	Signaler
{
	class SignalToken
	{
		get boolean shouldWait = true;
		
		public invalidate() => ()
		{
			shouldWait = false;
		}
	}

	private native readonly initSignaler(Pointer cond) => (int);
	private native readonly destroySignaler(Pointer cond) => (int);
	
	private native readonly wait(Pointer cond, Pointer mutex) => (int);
	private native readonly timedWait(Pointer cond, Pointer mutex, Pointer time) => (int);
	private native readonly broadcast(Pointer cond) => (int);
	
	private readonly native get handleSize() => (int);
	//private native readonly signal(Pointer cond) => (int);
	
	int waitingThreads = 0;
	Mutex mutex;
	Handle condHandle;
	ArrayDeque<SignalToken> tokensQueue;
	
	public create()
	{
		mutex = Mutex:create();
		condHandle = Handle:create(this->handleSize);
		tokensQueue = ArrayDeque<SignalToken>:create();
		
		initSignaler(condHandle->ptr);
	}
	
	public get waitingThreadsCount() => (int)
	{
		mutex.lock();
		var count = waitingThreads;
		mutex.unlock();
		
		return count;
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll().
	*
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify() => ()
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		var token = SignalToken:create();

		mutex.lock();
		try {
			tokensQueue.addLast(token);
			waitingThreads += 1;
			
			while(token->shouldWait) {
				// mutex unlocks when waiting
				wait(condHandle->ptr, mutex->ptr);
				// mutex locks back when finished waiting
			}
		} finally {
			waitingThreads -= 1;
			mutex.unlock();
		}
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll(), or until the specified amount of time elapsed.
	*
	* @param timeout The amount of time to wait before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify(TimeSpan timeout) => (boolean)
	{
		return waitSleep(timeout, false);
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll(), or until the specified amount of time elapsed.
	*
	* @param millisecondsTimeout The amount of time to wait, in milliseconds, before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify(int millisecondsTimeout) => (boolean)
	{		
		return waitSleep(Time.fromMilliSeconds(millisecondsTimeout), false);
	}
	
	public sleep(TimeSpan timeout) => ()
	{
		waitSleep(timeout, true);
	}
	
	public sleep(int millisecondsTimeout) => ()
	{		
		waitSleep(Time.fromMilliSeconds(millisecondsTimeout), true);
	}
	
	public notify() => () 
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}
		
		mutex.lock();
		try {
			// we would like to assure having a more or less organised wake up pattern.
			// Thus, notify should wake the threads up in the order that they went to sleep in.
			// we dequeue the first token, and broadcast to wake up all threads. However, since
			// we're in a loop, only one thread wakes up, which is the one we want.
			if(!tokensQueue.isEmpty()) {
				// we would like to avoid to notify wait which has already timedout.
				// when a wait timesout, it sets its own flag to false, so its token
				// could still be in the queue, but it is invalid and no threads are
				// listening on it. So we check for that. If the flag is false, we ignore
				// it and move on to the next one.
				SignalToken token;
				do {
					token = tokensQueue.removeFirst();
				} while(!tokensQueue.isEmpty() and !token->shouldWait);
				
				// found a valid flag, set to false, and notify it.
				token.invalidate();
				
				// notify all threads, but only one thread gets unlocked.
				broadcast(condHandle->ptr);
			}
		} finally {
			mutex.unlock();
		}
	}
	
	public notifyAll() => ()
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		mutex.lock();
		try {
			if(!tokensQueue.isEmpty()) {
				// we set all the wait flags to false
				do {
					tokensQueue
						.removeFirst()
						.invalidate();
					
					// notify all threads, but only one threads gets unlocked.
					broadcast(condHandle->ptr);
				} while(!tokensQueue.isEmpty());
			}
		} finally {
			mutex.unlock();
		}
	}
	
	public free() => ()
	{
		if(condHandle->isValid) {
			// we notify any waiting thread first
			notifyAll();
			
			// destroy errrything muahahahah
			destroySignaler(condHandle->ptr);
			condHandle.free();
			mutex.free();
		}
	}
	
	private waitSleep(TimeSpan timeout, boolean sleepOnly) => (boolean)
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		var time = AbsoluteTime:create(timeout);
		var token = SignalToken:create();
		int retVal = 0;
		
		mutex.lock();
		try {
			// we only add the token if we want to be able to wake this thread up later.
			// since we do not want any notify to wake that thread up, we do not add it to
			// the queue if we only want to sleep.
			if(!sleepOnly) {
				tokensQueue.addLast(token);
			}

			waitingThreads += 1;
			 // retVal is not zero when the wait times out
			while((retVal == 0 or !sleepOnly) and token->shouldWait) {
				// mutex unlocks when waiting
				retVal = timedWait(condHandle->ptr, mutex->ptr, time->ptr);
				// mutex locks back when finished waiting
			}
		} finally {
			waitingThreads -= 1;
			token.invalidate();
			mutex.unlock();
			time.free();
		}
		
		return (retVal != 0);
	}
}