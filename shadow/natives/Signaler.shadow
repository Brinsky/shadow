import shadow:utility;
import shadow:io@Console;

/**
* @author Claude Abounegm
*/
locked class shadow:natives@
	Signaler
{
	class SignalToken is CanEqual<SignalToken>
	{
		get Thread thread = curthread();
		get boolean shouldWait = true;
		get boolean interrupted = false;

		public invalidate() => ()
		{
			shouldWait = false;
		}
		
		public interrupt() => ()
		{
			invalidate();
			interrupted = true;
		}
		
		public readonly equal(SignalToken other) => (boolean)
		{
			return (this === other);
		}
	}

	private native readonly initSignaler(Pointer cond) => (int);
	private native readonly destroySignaler(Pointer cond) => (int);
	
	private native readonly wait(Pointer cond, Pointer mutex) => (int);
	private native readonly timedWait(Pointer cond, Pointer mutex, Pointer time) => (int);
	private native readonly broadcast(Pointer cond) => (int);
	
	private readonly native get handleSize() => (int);
	
	int waitingThreads = 0;
	Mutex mutex;
	Handle condHandle;
	LinkedList<SignalToken> tokensQueue;
	LinkedList<SignalToken> sleepTokensQueue;
	
	public create()
	{
		mutex = Mutex:create();
		condHandle = Handle:create(this->handleSize);
		tokensQueue = LinkedList<SignalToken>:create();
		sleepTokensQueue = LinkedList<SignalToken>:create();
		
		initSignaler(condHandle->ptr);
	}
	
	public readonly get waitingThreadsCount() => (int)
	{
		mutex.lock();
		var count = waitingThreads;
		mutex.unlock();
		
		return count;
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll().
	*
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify() => ()
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		var token = SignalToken:create();

		mutex.lock();
		try {
			tokensQueue.addLast(token);
			waitingThreads += 1;
			
			while(token->shouldWait) {
				wait(condHandle->ptr, mutex->ptr);
			}
			
			if(token->interrupted) {
				throw InterruptedException:create();
			}
		} finally {
			waitingThreads -= 1;
			mutex.forceOwnMutex();
			mutex.unlock();
		}
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll(), or until the specified amount of time elapsed.
	*
	* @param timeout The amount of time to wait before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify(TimeSpan timeout) => (boolean)
	{
		return waitSleep(timeout, false);
	}
	
	/**
	* Suspends the current thread until another thread calls notify() 
	* or notifyAll(), or until the specified amount of time elapsed.
	*
	* @param millisecondsTimeout The amount of time to wait, in milliseconds, before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	* @throws InvalidOperationException if this Signaler has been freed.
	*/
	public waitForNotify(int millisecondsTimeout) => (boolean)
	{		
		return waitSleep(Time.fromMilliSeconds(millisecondsTimeout), false);
	}
	
	public sleep(TimeSpan timeout) => ()
	{
		waitSleep(timeout, true);
	}
	
	public sleep(int millisecondsTimeout) => ()
	{		
		waitSleep(Time.fromMilliSeconds(millisecondsTimeout), true);
	}
	
	public notify() => () 
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}
		
		mutex.lock();
		try {
			// we would like to assure having a more or less organised wake up pattern.
			// Thus, notify should wake the threads up in the order that they went to sleep in.
			// we dequeue the first token, and broadcast to wake up all threads. However, since
			// we're in a loop, only one thread wakes up, which is the one we want.
			if(!tokensQueue.isEmpty()) {
				// We would like to avoid notifying a thread which has already timedout.
				// When a wait() timesout, it sets its own `shouldWait` flag to false, but 
				// does not remove itself from the queue. Thus the token could still be in queue.
				// This is an invalid token and no threads are listening on it. So we check for that. 
				// If the flag is false, we ignore it and move on to the next one.
				SignalToken token;
				do {
					token = tokensQueue.removeFirst();
				} while(!tokensQueue.isEmpty() and !token->shouldWait);
				
				// found a valid flag, set to false, and notify it.
				token.invalidate();
				
				// notify all threads, but only one thread gets unlocked.
				broadcast(condHandle->ptr);
			}
		} finally {
			mutex.unlock();
		}
	}
	
	public notifyAll() => ()
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		mutex.lock();
		try {
			while(!tokensQueue.isEmpty()) {
				tokensQueue
					.removeFirst()
					.invalidate();
				
				// notify all threads, but only one threads gets unlocked.
				broadcast(condHandle->ptr);
			}
		} finally {
			mutex.unlock();
		}
	}
	
	public interrupt(Thread thread) => ()
	{
		mutex.lock();
		try {
			if(!interruptToken(thread, tokensQueue) and !interruptToken(thread, sleepTokensQueue)) {
				throw InvalidOperationException:create("The thread could not be found.");
			}
			
			broadcast(condHandle->ptr);
		} finally {
			mutex.unlock();
		}
	}
	
	public free() => ()
	{
		if(condHandle->isValid) {
			// we notify any waiting thread first
			//interruptAll();
			notifyAll();
			
			// destroy errrything muahahahah
			destroySignaler(condHandle->ptr);
			condHandle.free();
			mutex.free();
		}
	}
	
	private waitSleep(TimeSpan timeout, boolean sleepOnly) => (boolean)
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		var time = AbsoluteTime:create(timeout);
		var token = SignalToken:create();
		int retVal = 0;
		
		mutex.lock();
		try {
			// we only add the token if we want to be able to wake this thread up later.
			// since we do not want any notify to wake that thread up, we do not add it to
			// the queue if we only want to sleep.
			if(!sleepOnly) {
				tokensQueue.addLast(token);
			} else {
				sleepTokensQueue.addLast(token);
			}

			waitingThreads += 1;
			 // retVal is not zero when the wait times out
			while((retVal == 0 or !sleepOnly) and token->shouldWait) {
				retVal = timedWait(condHandle->ptr, mutex->ptr, time->ptr);
			}
			
			if(token->interrupted) {
				Console.printLine("Interrupted");
				throw InterruptedException:create();
			}
		} finally {
			waitingThreads -= 1;
			token.invalidate();
			mutex.forceOwnMutex();
			mutex.unlock();
			time.free();
		}

		return (retVal != 0);
	}
	
	private interruptToken(Thread thread, LinkedList<SignalToken> list) => (boolean)
	{
		foreach(var t in list) {
			if(t->thread === thread) {
				t.interrupt();
				return true;
			}
		}
		
		return false;
	}
	
	/*public interruptAll() => ()
	{
		if(!condHandle->isValid) {
			throw InvalidOperationException:create("This Signaler is no longer valid.");
		}

		mutex.lock();
		try {			
			while(!tokensQueue.isEmpty()) {
				tokensQueue
					.removeFirst()
					.interrupt();
			}
			
			while(!sleepTokensQueue.isEmpty()) {
				sleepTokensQueue
					.removeFirst()
					.interrupt();
			}
			
			broadcast(condHandle->ptr);
		} finally {
			mutex.unlock();
		}
	}*/
}