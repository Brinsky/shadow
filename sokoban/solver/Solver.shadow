import shadow:io@Console;
import shadow:utility@List;
import shadow:utility@ArrayList;

class sokoban:solver@Solver {
	public main(String[] args) => () {
		System system = System:instance;
		Console console = Console:instance;

		List<String> rows = ArrayList<String>:create();
		int cols = 0;
		nullable String line;
		boolean eof;
		(line, eof) = console.readLine();
		try {
			while (!eof) {
				rows.add(check(line));
				cols = cols.max(check(line)->size);
				(line, eof) = console.readLine();
			}
		} recover {}

		ulong start = system.nanoTime();
		Board board = Board:create(rows, cols);
		Board:State state = board.getInitialState();
		nullable MutableString nullableSolution = recurse(state);
		ulong end = system.nanoTime();
		try
		{
			MutableString solution = check(nullableSolution);
			console.printLine("Solved in " # solution->size # " moves and " # (end - start) / 1000000000.0 # " seconds.").
					printLine(solution.reverse()).printLine("Press Enter to view playback.").readLine();
			for (int i = 0; i < solution->size; i += 1) {
				console.printLine(state);
				Board:State:Coordinate player = state.getPlayer();
				switch (cast<code>(solution[i])) {
					case ('U') {
						state = state.move(player, player.moveUp());
					} case ('D') {
						state = state.move(player, player.moveDown());
					} case ('L') {
						state = state.move(player, player.moveLeft());
					} case ('R') {
						state = state.move(player, player.moveRight());
					}
				}				
			}
			
			console.printLine(state).printLine("Done!");
		}
		recover
		{
			console.printLine("Unsolved after " # (end - start) / 1000000000.0 # " seconds.");
		}
	}
	int counter = 0;
	private recurse(nullable Board:State nullableState) => (nullable MutableString) {
		try
		{				
			Board:State state = check(nullableState);
			Console console = Console:instance;
			if (state.isWinning())
				return MutableString:create();
			counter += 1;
			if (counter >= 0 and counter % 256 == 0)
				console.print(state);
			for (int dist = 0; dist <= state.getMaxDistance(); dist += 1) {
				for (int num = 0; num < state.getNumCoordinates(dist); num += 1) {
					Board:State:Coordinate from = state.getCoordinate(dist, num);
					int index = 0;
					foreach (Board:State:Coordinate to in from) {
						nullable MutableString path = recurse(state.tryMove(from, to));
						if (path !== null)
							return state.getPath(check(path).append("UDLR"[index]), state.getPlayer(), from);
						index += 1;
					}
				}
			}
		}
		recover {}
		return null;
	}
}
