import shadow:utility;

class sokoban:solver@Board {
	constant int MAX = 256;
	constant code FLOOR = ' ', WALL = '#', TARGET = '.';
	ushort[] EMPTY = ushort:create[0];
	ushort width, height, boxCount;
	code[] board;
	State initial;
	State BAD_STATE = State:create();
	Set<State> stateSet;
	public create(List<String> rows, int cols) {
		if (cols <= 0 or cols >= MAX or rows.size() <= 0 or rows.size() >= MAX or (cols == MAX and rows.size() == MAX))
			throw IllegalArgumentException:create("Invalid size");
		width = cast<ushort>(cols);
		height = cast<ushort>(rows.size());
		ushort boxes = 0us, targets = 0us;
		for (int row = 0; row < height; row += 1)
			for (int col = 0; col < width; col += 1) {
				try {
					String rowText = check(rows[row]);
					if (rowText->size > col)
						switch (cast<code>(rowText[col])) {
							case ('$', 'o') {
								boxes += 1us;
							} case ('+', '.') {
								targets += 1us;
							} case ('*') {
								boxes += 1us;
								targets += 1us;
							}
						}
					}
					recover {}
				}
		if (boxes != targets)
			throw IllegalArgumentException:create("# boxes != # targets");
		if (boxes >= MAX * MAX - 1)
			throw IllegalArgumentException:create("Too many boxes");
		boxCount = boxes;
		board = code:create[width * height];
		State first = State:create();
		try {		
			foreach (State:Coordinate coord in first) {
				String rowText = check(rows[coord.getRow()]);			
				if(rowText->size <= coord.getCol())
					coord.setFloor();
				else switch (cast<code>(rowText[coord.getCol()])) {
					case ('#') {
						coord.setWall();
					} case (' ') {
						coord.setFloor();
					} case ('.') {
						coord.setFloor();
						coord.setTarget();
					} case ('$', 'o') {
						coord.setFloor();
						coord.addBox();
					} case ('*') {
						coord.setFloor();
						coord.setTarget();
						coord.addBox();
					} case ('@') {
						coord.setFloor();
						coord.setPlayer();
					} case ('+') {
						coord.setTarget();
						coord.setPlayer();
					} default {
						throw IllegalArgumentException:create();
					}
				}
			}
		}
		recover {}
		stateSet = HashSet<State>:create();
		initial = first.initialize();
	}

	public readonly getInitialState() => (State) {
		return initial;
	}
	public readonly getStates() => (Set<State>) {
		return stateSet;
	}
	public readonly toString() => (String) {
		return #initial;
	}

	public class State implements CanCompare<State>, CanIterate<Coordinate>, CanHash {
		int depth;
		//State parent;
		ushort[][] state;
		public create() {
			depth = 0;
			//parent = null;
			state = ushort[]:create[2];
			state[0] = ushort:create[boxCount + 1];
			for (int i = 1; i <= boxCount; i += 1)
				state[0][i] = 0xffffus;
			state[1] = ushort:create[1];
		}
		public create(State other, Coordinate player) {
			depth = other:depth + 1;
			//parent = other;
			state = ushort[]:create[2];
			state[0] = ushort:create[boxCount + 1];
			for( int i = 0; i < boxCount + 1; i += 1 )
				state[0][i] = other:state[0][i];
			state[1] = ushort:create[1];
			state[1][0] = player->index;
		}

		public initialize(ArrayDeque<Coordinate> queue, Coordinate last, Coordinate coord) => () {
			if (!coord.isWall() and !coord.hasBox() and coord.getDistance() == -1) {
				coord.setDistance(last.getDistance() + 1);
				queue.addLast(coord);
			}
		}
		
		public isValid() => (boolean) {
			return this !== BAD_STATE;
		}
		
		public initialize() => (State) {
			ArrayDeque<Coordinate> queue = ArrayDeque<Coordinate>:create();
			queue.addLast(getPlayer());
			while (!queue.isEmpty()) {
				Coordinate last = queue.removeFirst();
				foreach (Coordinate coord in last)
					initialize(queue, last, coord);
			}
			stateSet.add(this);			
			return stateSet.add(this) ? this, BAD_STATE;
		}

		public immutable getMaxDistance() => (int) {
			return state->size - 2;
		}
		public immutable getNumCoordinates(int dist) => (int) {
			return state[dist + 1]->size;
		}
		public immutable getCoordinate(int dist, int num) => (Coordinate) {
			return Coordinate:create(state[dist + 1][num]);
		}
		public immutable getPlayer() => (Coordinate) {
			return getCoordinate(0, 0);
		}
		public immutable getBoxes() => (CanIterate<Coordinate>) {
			return BoxIterable:create();
		}
		private immutable class BoxIterable implements CanIterate<Coordinate> {
			public immutable iterator() => (Iterator<Coordinate>) {
				return BoxIterator:create();
			}
		}
		private class BoxIterator implements Iterator<Coordinate> {
			ushort index = 0us;
			public immutable hasNext() => (boolean) {
				return index < state[0][0];
			}
			public next() => (Coordinate) {
				if (index >= state[0][0])
					throw NoSuchElementException:create();
				index += 1us;
				return Coordinate:create(state[0][index]);
			}
		}

		public immutable isLosing(Coordinate box) => (boolean) {
			if (!box.isTarget()) {
				if (box.moveUp().isWall() and box.moveRight().isWall())
					return true;
				if (box.moveRight().isWall() and box.moveDown().isWall())
					return true;
				if (box.moveDown().isWall() and box.moveLeft().isWall())
					return true;
				if (box.moveLeft().isWall() and box.moveUp().isWall())
					return true;
				if (box.moveUp().isFull() and box.moveRight().isFull() and box.moveUpRight().isFull())
					return true;
				if (box.moveRight().isFull() and box.moveDown().isFull() and box.moveDownRight().isFull())
					return true;
				if (box.moveDown().isFull() and box.moveLeft().isFull() and box.moveDownLeft().isFull())
					return true;
				if (box.moveLeft().isFull() and box.moveUp().isFull() and box.moveUpLeft().isFull())
					return true;
			}
			if (box.moveLeft().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveLeft().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveUp();
				}
				current = box.moveDown();
				while (!current.isWall() and wall) {
					if (!current.moveLeft().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveDown();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (box.moveRight().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveRight().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveUp();
				}
				current = box.moveDown();
				while (!current.isWall() and wall) {
					if (!current.moveRight().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveDown();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (box.moveUp().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveUp().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveRight();
				}
				current = box.moveLeft();
				while (!current.isWall() and wall) {
					if (!current.moveUp().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveLeft();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (box.moveDown().isWall()) {
				boolean wall = true;
				int targets = 0, boxes = 0;
				Coordinate current = box;
				while (!current.isWall() and wall) {
					if (!current.moveDown().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveRight();
				}
				current = box.moveLeft();
				while (!current.isWall() and wall) {
					if (!current.moveDown().isWall())
						wall = false;
					if (current.isTarget())
						targets += 1;
					if (current.hasBox())
						boxes += 1;
					current = current.moveLeft();
				}
				if (wall and boxes > targets)
					return true;
			}
			if (isUnreachableArea(box.moveUpLeft(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveUp(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveUpRight(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveRight(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveDownRight(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveDown(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveDownLeft(), HashSet<Coordinate>:create()))
				return true;
			if (isUnreachableArea(box.moveLeft(), HashSet<Coordinate>:create()))
				return true;
			return false;
		}
		private immutable isUnreachableArea(Coordinate center, Set<Coordinate> area) => (boolean) {
			if (center.isTarget() or center.isFull() or center.isReachable())
				return false;
			if (!area.add(center))
				return true;
			foreach (Coordinate coord in center)
				if (coord.isEmpty() and !isUnreachableArea(coord, area))
					return false;
			foreach (Coordinate coord in center)
				if (coord.hasBox() and !center.over(coord).isWall() and !coord.over(center).isWall() and !area.contains(center.over(coord)))
					return false;
			if (center.moveUpLeft().isEmpty() and !area.contains(center.moveUpLeft())) {
				if (center.moveUp().hasBox() and center.moveUpRight().isEmpty())
					return false;
				if (center.moveLeft().hasBox() and center.moveDownLeft().isEmpty())
					return false;
			}
			if (center.moveUpRight().isEmpty() and !area.contains(center.moveUpRight())) {
				if (center.moveUp().hasBox() and center.moveUpLeft().isEmpty())
					return false;
				if (center.moveRight().hasBox() and center.moveDownRight().isEmpty())
					return false;
			}
			if (center.moveDownLeft().isEmpty() and !area.contains(center.moveDownLeft())) {
				if (center.moveDown().hasBox() and center.moveDownRight().isEmpty())
					return false;
				if (center.moveLeft().hasBox() and center.moveUpLeft().isEmpty())
					return false;
			}
			if (center.moveDownRight().isEmpty() and !area.contains(center.moveDownRight())) {
				if (center.moveDown().hasBox() and center.moveDownLeft().isEmpty())
					return false;
				if (center.moveRight().hasBox() and center.moveUpRight().isEmpty())
					return false;
			}
			return true;
		}
		public readonly isWinning() => (boolean) {
			foreach (Coordinate coord in getBoxes())
				if (!coord.isTarget())
					return false;
			return true;
		}
		public tryMove(Coordinate from, Coordinate to) => (State) {
			if (!to.hasBox())
				return BAD_STATE;
			Coordinate next = from.over(to);
			if (next.isWall() or next.hasBox())
				return BAD_STATE;
			State state = State:create(this, to);
			state.getPlayer().removeBox();
			Coordinate box = state:Coordinate:create(next).addBox();
			state = state.initialize();
			if( state === BAD_STATE or state.isLosing(box) )
					return BAD_STATE;
			stateSet.add(this);
			return state;
		}
		public move(Coordinate from, Coordinate to) => (State) {
			State state = State:create(this, to);
			if (to.hasBox()) {
				Coordinate next = from.over(to);
				if (next.isWall() or next.hasBox())
					return BAD_STATE;
				state.getPlayer().removeBox();
				state:Coordinate:create(next).addBox();
			}
			return state;
		}
		public getPath(MutableString sb, Coordinate from, Coordinate to) => (MutableString) {
			while (!to.equal(from))
				to = getMove(sb, to);
			return sb;
		}
		public getMove(MutableString sb, Coordinate to) => (Coordinate) {
			int index = 0;
			foreach (Coordinate from in to) {
				if (from.getDistance() == to.getDistance() - 1) {
					sb.append("DURL"[index]);
					return from;
				}
				index += 1;
			}
			throw IllegalArgumentException:create("Where did I come from?");
		}

		public readonly compare(State other) => (int) {
			return depth - other:depth;
		}
		public readonly equal(State other) => (boolean) {
			if (state[0] !== other:state[0])
				return false;
			foreach (Coordinate otherCoord in other) {
				Coordinate thisCoord = Coordinate:create(otherCoord);
				if (thisCoord.hasBox() != otherCoord.hasBox() or
						thisCoord.isReachable() != otherCoord.isReachable())
					return false;
			}
			return true;
		}
		
		public get readonly hash() => ( uint ) {		
			uint hash = 0u;
			for (int i = 0; i < state->size; i += 1) {
				if (i == 1)
					hash <<= 16;
				for (int j = 0; j < state[i]->size; j += 1)
					hash ^= state[i][j];
			}
			return hash;
		}
		public readonly toString() => (String) {
			MutableString sb = MutableString:create();
			for (int row = 0; row < height; row += 1) {
				for (int col = 0; col < width; col += 1) {
					Coordinate coord = Coordinate:create(row, col);
					if (coord.isWall())
						sb.append('#');
					else if (coord.hasPlayer())
						sb.append('@');
					else if (coord.isTarget() and coord.hasBox())
						sb.append('*');
					else if (coord.hasBox())
						sb.append('o');
					else if (coord.isTarget())
						sb.append('.');
					else
						sb.append(' ');
				}
				/*sb.append(" | ");
				for (int col = 0; col < width; col += 1) {
					Coordinate coord = new Coordinate(row, col);
					if (coord.isWall())
						sb.append("##");
					else if (coord.hasBox())
						sb.append("[]");
					else if (coord.getDistance() < 0)
						sb.append("  ");
					else
						sb.append(String.format("%02d", coord.getDistance()));
				}*/
				sb.append("\n");
			}
			return sb.toString();
		}

		public class Coordinate implements CanCompare<Coordinate>, CanIterate<Coordinate>, CanHash {
			get ushort index;
			public create() {
				index = 0us;
			}
			public create(int i) {
				if (i >= board->size)
					throw IllegalArgumentException:create();
				index = cast<ushort>(i);
			}
			public create(int row, int col) {
				this(row * width + col);
			}
			public create(Coordinate other) {
				this(other.getRow(), other.getCol());
			}
			
			public readonly hasNext() => (boolean) {
				return index + 1 < board->size;
			}

			public next() => (Coordinate) {				
				return Coordinate:create(index + 1);				
			}
			public over(Coordinate next) => (Coordinate) {				
				return Coordinate:create(2 * next.getRow() - getRow(), 2 * next.getCol() - getCol());
			}
			public away(Coordinate from) => (Coordinate) {
				return from.over(this);
			}
			public findBox() => (int) {
				ushort[] boxes = state[0];
				int value = index, min = 1, max = boxes[0];
				while (min <= max) {
					int mid = (min + max) >>> 1;
					if (boxes[mid] < value)
						min = mid + 1;
					else if (boxes[mid] > value)
						max = mid - 1;
					else
						return mid;
				}
				return max;
			}

			public setFloor() => () {
				board[index] = FLOOR;
			}
			public setWall() => () {
				board[index] = WALL;
			}
			public setTarget() => () {
				board[index] = TARGET;
			}
			public addBox() => (Coordinate) {
				ushort[] boxes = state[0];
				int loc = findBox();
				if (boxes[loc] != index) {
					loc += 1;					
					for( int i = boxes[0] - 1; i >= loc; i -= 1 ) 
						boxes[i + 1] = boxes[i];
					boxes[0] += 1us;
					boxes[loc] = index;
				}
				return this;
			}
			public removeBox() => (Coordinate) {
				ushort[] boxes = state[0];
				int loc = findBox();
				if (boxes[loc] == index) {
					for( int i = loc; i < boxes[0]; i -= 1 ) 
						boxes[i] = boxes[i + 1];					
					boxes[0] -= 1us;
					boxes[boxes[0]] = 0xffffus;					
				}
				return this;
			}
			public setPlayer() => () {
				state[1][0] = index;
			}
			public setDistance(int dist) => () {
				dist += 1;
				if (dist > 0) {
					if (dist >= state->size) {
						ushort[][] newState = ushort[]:create[dist + 1];
						for( int i = 0; i < state->size; i += 1 )
							newState[i] = state[i];
						for (int i = state->size; i <= dist; i += 1)
							newState[i] = EMPTY;
						state = newState;
					}
					ushort[] oldArray = state[dist];
					ushort[] newArray = ushort:create[oldArray->size + 1];
					for( int i = 0; i < oldArray->size; i += 1 )
						newArray[i] = oldArray[i];
					newArray[oldArray->size] = index;
					state[dist] = newArray;
				}
			}
			public readonly getDistance() => (int) {
				for (int dist = 1; dist < state->size; dist += 1)
					for (int i = 0; i < state[dist]->size; i += 1)
						if (state[dist][i] == index)
							return dist - 1;
				return -1;
			}
			public readonly isReachable() => (boolean) {
				return getDistance() != -1;
			}

			public readonly getRow() => (int) {
				return index / width;
			}
			public readonly getCol() => (int) {
				return index % width;
			}
			public readonly isFloor() => (boolean) {
				return board[index] == FLOOR;
			}
			public readonly isWall() => (boolean) {
				return board[index] == WALL;
			}
			public readonly isTarget() => (boolean)  {
				return board[index] == TARGET;
			}
			public readonly hasBox() => (boolean) {
				ushort[] boxes = state[0];
				int value = index, min = 1, max = boxes[0];
				while (min <= max) {
					int mid = (min + max) >>> 1;
					if (boxes[mid] < value)
						min = mid + 1;
					else if (boxes[mid] > value)
						max = mid - 1;
					else
						return true;
				}
				return false;
			}
			public readonly isFull() => (boolean) {
				return board[index] == WALL or hasBox();
			}
			public readonly isEmpty() => (boolean) {
				return board[index] != WALL and !hasBox();
			}
			public readonly hasPlayer() => (boolean) {
				return state[1][0] == index;
			}

			public moveUp() => (Coordinate) {
				return Coordinate:create(index - width);
			}
			public moveDown() => (Coordinate) {
				return Coordinate:create(index + width);
			}
			public moveLeft() => (Coordinate) {
				return Coordinate:create(index - 1);
			}
			public moveRight() => (Coordinate) {
				return Coordinate:create(index + 1);
			}
			public moveUpLeft() => (Coordinate) {
				return Coordinate:create(index - width - 1);
			}
			public moveUpRight() => (Coordinate) {
				return Coordinate:create(index - width + 1);
			}
			public moveDownLeft() => (Coordinate) {
				return Coordinate:create(index + width - 1);
			}
			public moveDownRight() => (Coordinate) {
				return Coordinate:create(index + width + 1);
			}

			public readonly equal(Coordinate other) => (boolean) {				
					return index == other:index;				
			}
			public readonly compare(Coordinate other) => (int) {
				return index - other:index;
			}
			public get readonly hash() => (uint) {
				return index;
			}
			public readonly toString() => (String) {
				MutableString sb = MutableString:create();
				for (int row = 0; row < height; row += 1) {
					for (int col = 0; col < width; col += 1) {
						Coordinate coord = Coordinate:create(row, col);
						if (equal(coord))
							sb.append('X');
						else if (coord.isWall())
							sb.append('#');
						else if (coord.hasPlayer())
							sb.append('@');
						else if (coord.isTarget() and coord.hasBox())
							sb.append('*');
						else if (coord.hasBox())
							sb.append('o');
						else if (coord.isTarget())
							sb.append('.');
						else
							sb.append(' ');
					}
					sb.append("\n");
				}
				return sb.toString();
			}

			public iterator() => (Iterator<Coordinate>) {
				return CoordinateIterator:create();
			}
			private class CoordinateIterator implements Iterator<Coordinate> {
				int state = 0;
				public immutable hasNext() => (boolean) {
					return state < 4;
				}
				public next() => (Coordinate) {
					switch (state) {
						case (0) {
							state += 1;
							return moveUp();
						} case (1) {
							state += 1;
							return moveDown();
						} case (2) {
							state += 1;
							return moveLeft();
						} case (3) {
							state += 1;
							return moveRight();
						} default {
							throw NoSuchElementException:create();
						}
					}
				}
			}
		}

		public immutable iterator() => (Iterator<Coordinate>) {
			return StateIterator:create();
		}
		private class StateIterator implements Iterator<Coordinate> {
			Coordinate current = Coordinate:create();
			public immutable hasNext() => (boolean) {
				return current.hasNext();
			}
			public next() => (Coordinate) {				
				Coordinate temp = current;
				current = temp.next();
				return temp;
			}
		}
	}
}
